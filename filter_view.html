<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBTI Filter View</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <script src="path/to/mbti_heatmap_radial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- å…ˆå¼•å…¥ Chart.js UMD å…¨å±€ç‰ˆ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <!-- å†å¼•å…¥ DataLabels æ’ä»¶çš„ UMD ç‰ˆ -->
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
        import { getDatabase, ref, query, orderByChild, equalTo, get } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-database.js";
        Chart.register(ChartDataLabels);
        const firebaseConfig = {
            apiKey: "AIzaSyCvc9C5PuDqrI26jrmsg5b1PVOW6_k43W4",
            authDomain: "mbti-kale.firebaseapp.com",
            databaseURL: "https://mbti-kale-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "mbti-kale",
            storageBucket: "mbti-kale.firebasestorage.app",
            messagingSenderId: "756176954275",
            appId: "1:756176954275:web:7581e5e485e426b33ff016",
            measurementId: "G-B6F0F4JZ7E"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const urlParams = new URLSearchParams(window.location.search);
        const username = urlParams.get("name");
        const filterType = urlParams.get("filter") || "relationshipType";
        const MyMBTI = urlParams.get("mbti");
        let userTypeGroup = "", groupColor = "", groupDescription = "";
        let topMisperceiveColor = "";
        function find_color(type) {
            let color = "#CCCCCC"; // é»˜è®¤ç°è‰²
            if (["INTJ", "INTP", "ENTJ", "ENTP"].includes(type)) {
                color = "#9B6784";
            } else if (["INFJ", "INFP", "ENFJ", "ENFP"].includes(type)) {
                color = "#61AD89";
            } else if (["ISTJ", "ISFJ", "ESTJ", "ESFJ"].includes(type)) {
                color = "#80CCDF";
            } else if (["ISTP", "ISFP", "ESTP", "ESFP"].includes(type)) {
                color = "#E1C134";
            }
            return color;
        }
        if (["INTJ", "INTP", "ENTJ", "ENTP"].includes(MyMBTI)) {
            userTypeGroup = "Analyst";
            groupColor = "#9B6784";
            groupDescription = "rational, logical, and objective thinkers who excel at problem-solving and strategic planning";
        } else if (["INFJ", "INFP", "ENFJ", "ENFP"].includes(MyMBTI)) {
            userTypeGroup = "Diplomat";
            groupColor = "#61AD89";
            groupDescription = "empathetic, idealistic, and value-driven individuals who focus on personal growth and meaningful connections";
        } else if (["ISTJ", "ISFJ", "ESTJ", "ESFJ"].includes(MyMBTI)) {
            userTypeGroup = "Sentinel";
            groupColor = "#80CCDF";
            groupDescription = "practical, detail-oriented, and responsibility-focused individuals who value security and tradition";
        } else if (["ISTP", "ISFP", "ESTP", "ESFP"].includes(MyMBTI)) {
            userTypeGroup = "Explorer";
            groupColor = "#E1C134";
            groupDescription = "spontaneous, adaptable, and present-focused individuals who excel at practical problem-solving and enjoying the moment";
        }
        // åœ¨ä½ çš„è„šæœ¬é‡Œï¼ˆç¡®ä¿åœ¨ MyMBTI å·²ç»æœ‰å€¼åè¿è¡Œï¼‰ï¼š
        const legendConfig = [
            { code: 'I/E', keys: ['I', 'E'], labels: ['Introverted', 'Extroverted'], css: 'ie-color' },
            { code: 'N/S', keys: ['N', 'S'], labels: ['Intuitive', 'Sensing'], css: 'ns-color' },
            { code: 'F/T', keys: ['F', 'T'], labels: ['Feeling', 'Thinking'], css: 'ft-color' },
            { code: 'J/P', keys: ['J', 'P'], labels: ['Judging', 'Perceiving'], css: 'jp-color' }
        ];


        let allData = [];

        document.addEventListener('DOMContentLoaded', async function () {
            // Update the MBTI title with the user's MBTI type from URL
            const mbtiParts = MyMBTI.split('');

            document.getElementById("mbti-title").innerHTML = `Your MBTI Type: <span class="mbti-highlight" style=" color: ${groupColor};">${mbtiParts.join('')} (${userTypeGroup})</span>`;

            await fetchData();
            processData();
        });
        async function fetchData() {
            try {
                const dbRef = ref(database, "responses");
                const q = query(dbRef, orderByChild("username"), equalTo(username));
                const snapshot = await get(q);
                allData = [];

                if (!snapshot.exists()) {
                    console.log("No data found for this username");
                    document.querySelector(".summary-title").innerHTML = "No data found for this username";
                    return;
                }

                snapshot.forEach(child => {
                    const d = child.val();
                    if (d.ie && d.ns && d.ft && d.jp) {
                        // Directly create MBTI type from the string values
                        const mbtiType = d.ie + d.ns + d.ft + d.jp;

                        // Convert string values to numerical for charts
                        const ieVal = d.ie === "I" ? -1 : 1;
                        const nsVal = d.ns === "N" ? -1 : 1;
                        const ftVal = d.ft === "F" ? -1 : 1;
                        const jpVal = d.jp === "J" ? -1 : 1;

                        allData.push({
                            email: d.email,
                            ie: ieVal,
                            ns: nsVal,
                            ft: ftVal,
                            jp: jpVal,
                            ieStr: d.ie,
                            nsStr: d.ns,
                            ftStr: d.ft,
                            jpStr: d.jp,
                            mbtiType: mbtiType,
                            familiarity: parseInt(d.intimacyGraphReverse) || 1,
                            intimacy: parseInt(d.intimacyGraph) || 1,
                            relationshipType: d.relationshipType || "Unknown",
                            sinceWhen: d.sinceWhen || "Unknown",
                            interactionPlace: d.interactionPlace || "Unknown",
                        });
                        console.log("Processed data entry:", mbtiType, ieVal, nsVal, ftVal, jpVal);
                    }
                });

                console.log("Fetched data:", allData);
            } catch (error) {
                console.error("Error fetching data:", error);
                document.querySelector(".summary-title").innerHTML = "Error fetching data: " + error.message;
            }
        }

        // This function is no longer needed as we're using the string values directly
        // Keeping it here in case we need to convert numerical values to MBTI strings in the future
        function getMBTIFromTraits(ie, ns, ft, jp) {
            if (typeof ie === 'string') return ie + ns + ft + jp;

            return (ie < 0 ? "I" : "E") +
                (ns < 0 ? "N" : "S") +
                (ft < 0 ? "F" : "T") +
                (jp < 0 ? "J" : "P");
        }

        function processData() {
            if (allData.length === 0) return;

            // Calculate MBTI type distribution
            const mbtiCounts = {};
            allData.forEach(person => {
                const type = person.mbtiType;
                mbtiCounts[type] = (mbtiCounts[type] || 0) + 1;
            });

            // Calculate trait statistics
            let iCount = 0, eCount = 0, nCount = 0, sCount = 0, fCount = 0, tCount = 0, jCount = 0, pCount = 0;
            allData.forEach(person => {
                if (person.ieStr === "I") iCount++;
                if (person.ieStr === "E") eCount++;
                if (person.nsStr === "N") nCount++;
                if (person.nsStr === "S") sCount++;
                if (person.ftStr === "F") fCount++;
                if (person.ftStr === "T") tCount++;
                if (person.jpStr === "J") jCount++;
                if (person.jpStr === "P") pCount++;
            });

            const total = allData.length;
            const iPercent = Math.round((iCount / total) * 100);
            const ePercent = Math.round((eCount / total) * 100);
            const nPercent = Math.round((nCount / total) * 100);
            const sPercent = Math.round((sCount / total) * 100);
            const fPercent = Math.round((fCount / total) * 100);
            const tPercent = Math.round((tCount / total) * 100);
            const jPercent = Math.round((jCount / total) * 100);
            const pPercent = Math.round((pCount / total) * 100);

            // Find most common mistype
            const mistypes = {};
            allData.forEach(person => {
                if (person.mbtiType !== MyMBTI) {
                    mistypes[person.mbtiType] = (mistypes[person.mbtiType] || 0) + 1;
                }
            });

            let mostCommonMistype = "None";
            const entries = Object.entries(mistypes);
            if (entries.length > 0) {
                const maxValue = Math.max(...entries.map(([_, val]) => val));
                const topTypes = entries.filter(([_, val]) => val === maxValue).map(([key]) => key);
                mostCommonMistype = topTypes.length === 1 ? topTypes[0] : topTypes.join(", ");
            }


            // Calculate average traits for comparison chart
            let avgIE = 0, avgNS = 0, avgFT = 0, avgJP = 0;
            allData.forEach(person => {
                avgIE += person.ie;
                avgNS += person.ns;
                avgFT += person.ft;
                avgJP += person.jp;
            });

            avgIE /= allData.length;
            avgNS /= allData.length;
            avgFT /= allData.length;
            avgJP /= allData.length;

            // Calculate perception by relationship
            const relationshipPerception = {};
            allData.forEach(person => {
                const rel = person.relationshipType;
                if (!relationshipPerception[rel]) {
                    relationshipPerception[rel] = {
                        types: {},
                        count: 0
                    };
                }
                relationshipPerception[rel].count++;
                relationshipPerception[rel].types[person.mbtiType] =
                    (relationshipPerception[rel].types[person.mbtiType] || 0) + 1;
            });

            // Update UI
            updateSummary(allData.length, allData.filter(p => p.mbtiType !== MyMBTI).length,
                mostCommonMistype, iPercent, ePercent, nPercent, sPercent,
                fPercent, tPercent, jPercent, pPercent, MyMBTI, mbtiCounts);

            filterConfigs.forEach(({ key, selectId }) => {
                const sel = document.getElementById(selectId);
                // å…ˆæ¸…ä¸€ä¸‹ï¼šä¿ç•™ç¬¬ä¸€ä¸ªâ€œAllâ€ï¼Œåˆ æ‰å…¶ä½™æ—§ option
                while (sel.options.length > 1) sel.remove(1);

                // å–è¯¥å­—æ®µçš„æ‰€æœ‰å”¯ä¸€å€¼
                const uniques = Array.from(new Set(
                    allData.map(p => p[key] != null ? p[key] : 'Unknown')
                ));

                // å¦‚æœå…¨æ˜¯æ•°å­—åˆ™æŒ‰æ•°å­—æ’ï¼Œå¦åˆ™æŒ‰å­—ç¬¦ä¸²æ’
                const allNums = uniques.every(v => typeof v === 'number');
                uniques.sort((a, b) => {
                    if (allNums) return a - b;
                    return String(a).localeCompare(String(b));
                });

                uniques.forEach(v => {
                    const opt = document.createElement('option');
                    opt.value = v;           // ä¿ç•™åŸå€¼ï¼ˆæ•°å­—ä¹Ÿ OKï¼‰
                    const str = String(v);   // å…ˆè½¬å­—ç¬¦ä¸²
                    opt.text = str
                        .replace(/_/g, ' ')
                        .replace(/\b\w/g, c => c.toUpperCase());
                    sel.appendChild(opt);
                });
            });
            // â€”â€” å¡«å……å®Œæˆ â€”â€”
            // drawMBTINetworkChart(mbtiCounts);
            // drawMBTINetworkChart();
            //updateFilterSections();
            //drawFigure(mbtiCounts);
            drawMBTIPerception(mbtiCounts);
            filterConfigs.forEach(({ selectId }) => {
                const sel = document.getElementById(selectId);
                sel.removeEventListener('change', onFilterChange);
                sel.addEventListener('change', onFilterChange);
            });
            updateCombinedRadar();

        }
        // mbti_heatmap_radial.js
        // æåæ ‡ MBTI çƒ­åŠ›å›¾ï¼šå±‚çº§æ˜¾ç¤ºå·®å¼‚ï¼Œé¢œè‰²è¡¨ç¤ºè¯¯è®¤æ¯”ä¾‹ï¼Œå¤§å°è¡¨ç¤ºäººæ•°ï¼Œæ”¯æŒæ‚¬æµ®æç¤º
        // æ–‡æœ¬ç¾åŒ–ï¼šç»Ÿä¸€ Poppins å­—ä½“ï¼Œé€‚å½“åŠ ç²—å’Œé—´è·ï¼Œæé«˜å¯è¯»æ€§

        let clickCount = 0;
        let activeNodesSet = new Set();
        let lastClickedNode = "none";

        // function drawFigure(mbtiCounts) {
        //     // åŸºç¡€å°ºå¯¸ - è°ƒæ•´å›¾è¡¨å°ºå¯¸
        //     const typeGroups = [
        //         { name: "Analysts", types: ["INTJ", "INTP", "ENTJ", "ENTP"], color: "#9B6784", lineColor: "#9B6784" },
        //         { name: "Diplomats", types: ["INFJ", "INFP", "ENFJ", "ENFP"], color: "#61AD89", lineColor: "#61AD89" },
        //         { name: "Sentinels", types: ["ISTJ", "ISFJ", "ESTJ", "ESFJ"], color: "#80CCDF", lineColor: "#80CCDF" },
        //         { name: "Explorers", types: ["ISTP", "ISFP", "ESTP", "ESFP"], color: "#E1C134", lineColor: "#E1C134" }
        //     ];

        //     const baseWidth = 400;
        //     const baseHeight = 400; // å¢åŠ é«˜åº¦ä»¥é€‚åº”æ›´å¤šå†…å®¹
        //     const marginTop = 10;  // å‡å°‘é¡¶éƒ¨è¾¹è·
        //     const marginLeft = 60;
        //     const width = baseWidth;
        //     const height = baseHeight;

        //     // æ¸…ç©ºä¹‹å‰çš„å›¾è¡¨
        //     d3.select('#mbtiSankeyChart').selectAll('*').remove();

        //     // åˆ›å»º SVGï¼Œç»Ÿä¸€å­—ä½“
        //     const svg = d3.select('#mbtiSankeyChart')
        //         .append('svg')
        //         .attr('width', width)
        //         .attr('height', height)
        //         .style('font-family', 'Poppins, sans-serif')
        //         .style('font-weight', 'bold');

        //     // çœŸå®ç±»å‹ä¸è®¡æ•°
        //     const MyMBTI = (new URLSearchParams(window.location.search).get('mbti') || 'INFP').toUpperCase();
        //     const allTypes = ['ISTJ', 'ISFJ', 'INFJ', 'INTJ', 'ISTP', 'ISFP', 'INFP', 'INTP', 'ESTP', 'ESFP', 'ENFP', 'ENTP', 'ESTJ', 'ESFJ', 'ENFJ', 'ENTJ'];

        //     // æ•°æ®ç»Ÿè®¡
        //     const total = d3.sum(allTypes, t => mbtiCounts[t] || 0);

        //     // æ‰¾å‡ºå‡ºç°æœ€å¤šçš„ç±»å‹åŠå…¶æ•°é‡
        //     const maxType = d3.max(allTypes, t => mbtiCounts[t] || 0);

        //     // è®¡ç®—æœ€å¤šçš„ç±»å‹å æ•´ä½“çš„ç™¾åˆ†æ¯”
        //     const max_ratio = maxType / total;

        //     // åˆ›å»ºå‘å…‰æ•ˆæœ
        //     const defs = svg.append('defs');

        //     // æ·»åŠ å‘å…‰æ»¤é•œ
        //     const filter = defs.append('filter')
        //         .attr('id', 'glow')
        //         .attr('x', '-50%')
        //         .attr('y', '-50%')
        //         .attr('width', '200%')
        //         .attr('height', '200%');

        //     // æ·»åŠ æ¨¡ç³Šæ•ˆæœ
        //     filter.append('feGaussianBlur')
        //         .attr('stdDeviation', '2.5')
        //         .attr('result', 'coloredBlur');

        //     // åˆå¹¶åŸå§‹å›¾å½¢å’Œæ¨¡ç³Šæ•ˆæœ
        //     const feMerge = filter.append('feMerge');
        //     feMerge.append('feMergeNode')
        //         .attr('in', 'coloredBlur');
        //     feMerge.append('feMergeNode')
        //         .attr('in', 'SourceGraphic');

        //     // ä¸»åˆ†ç»„ä½ç§»
        //     const g = svg.append('g')
        //         .attr('transform', `translate(${marginLeft},${marginTop + 40})`); // é¢å¤–åç§»ï¼Œä¸ºæ ‡é¢˜è…¾å‡ºç©ºé—´

        //     // æ±‰æ˜è·ç¦»è®¡ç®—
        //     function hammingDistance(a, b) {
        //         let distance = 0;
        //         for (let i = 0; i < 4; i++) {
        //             if (a[i] !== b[i]) distance++;
        //         }
        //         return distance;
        //     }

        //     // èŠ‚ç‚¹å¤§å°è®¡ç®—
        //     function calculateNodeSize(ratio) {
        //         // å°äº1%çš„èŠ‚ç‚¹ä¹Ÿè¦æœ‰æœ€å°å°ºå¯¸
        //         if (ratio < 0.01) return 4;
        //         // ä½¿ç”¨å¹³æ–¹æ ¹æ¯”ä¾‹å°ºä»¥æ›´å¥½åœ°æ˜¾ç¤ºè¾ƒå°æ¯”ä¾‹
        //         return 4 + Math.sqrt(ratio * 100) * 2;
        //     }

        //     // æ ¹æ®æ±‰æ˜è·ç¦»å¯¹ç±»å‹è¿›è¡Œåˆ†ç»„
        //     function groupByHammingDistance() {
        //         const grouped = [[], [], [], [], []];

        //         // è‡ªå·±çš„ç±»å‹æ”¾åœ¨ç¬¬ä¸€ç»„
        //         grouped[0].push({
        //             type: MyMBTI,
        //             ratio: (mbtiCounts[MyMBTI] || 0) / total,
        //             diff: 0
        //         });

        //         // å…¶ä»–ç±»å‹æŒ‰æ±‰æ˜è·ç¦»åˆ†ç»„
        //         allTypes.forEach(type => {
        //             if (type === MyMBTI) return; // è·³è¿‡è‡ªå·±çš„ç±»å‹

        //             const diff = hammingDistance(type, MyMBTI);
        //             const ratio = (mbtiCounts[type] || 0) / total;

        //             grouped[diff].push({
        //                 type: type,
        //                 ratio: ratio,
        //                 diff: diff
        //             });
        //         });

        //         return grouped;
        //     }

        //     // ç»˜åˆ¶åˆ—æ ‡é¢˜
        //     function drawColumnHeaders() {
        //         const titles = [
        //             '4 matchs ',
        //             '3 matchs',
        //             '2 matchs',
        //             '1 match',
        //             '0 match'
        //         ];
        //         // å°†æ ‡é¢˜ç§»åˆ°SVGé¡¶éƒ¨
        //         const columnWidth = (baseWidth - marginLeft - 40) / 5;
        //         // åˆ›å»ºæ ‡é¢˜è¡Œ
        //         const titleGroup = svg.append('g')
        //             .attr('transform', `translate(${marginLeft}, 20)`);
        //         titles.forEach((title, i) => {
        //             titleGroup.append('text')
        //                 .attr('x', i * columnWidth + columnWidth / 2)
        //                 .attr('y', 30)
        //                 .attr('text-anchor', 'middle')
        //                 .attr('font-size', '10px')
        //                 .attr('font-weight', 'bold')
        //                 .text(title);
        //         });

        //         // æ·»åŠ ç°è‰²åˆ†éš”çº¿
        //         for (let i = 1; i < 5; i++) {
        //             svg.append('line')
        //                 .attr('x1', marginLeft + i * columnWidth)
        //                 .attr('y1', 80) // ä»æ ‡é¢˜ä¸‹æ–¹å¼€å§‹
        //                 .attr('x2', marginLeft + i * columnWidth)
        //                 .attr('y2', height - 20) // åˆ°å›¾è¡¨åº•éƒ¨ç»“æŸ
        //                 .attr('stroke', '#D3D3D3') // æµ…ç°è‰²
        //                 .attr('stroke-width', 2)
        //                 .attr('stroke-dasharray', '4,4') // è™šçº¿æ•ˆæœ
        //                 .attr('opacity', 0.7); // åŠé€æ˜
        //         }
        //     }

        //     // ç»˜åˆ¶ MBTI ç±»å‹åœ†åœˆå’Œæ–‡æœ¬
        //     function renderMBTICircles() {
        //         const columnWidth = (baseWidth - marginLeft - 40) / 5;
        //         const groupedTypes = groupByHammingDistance();

        //         // è®¡ç®—æ¯åˆ—å†…å®¹çš„å‚ç›´åˆ†å¸ƒ
        //         for (let diffIndex = 0; diffIndex < groupedTypes.length; diffIndex++) {
        //             const group = groupedTypes[diffIndex];

        //             // å„åˆ—é«˜åº¦çº¦æŸ - ä½¿ç”¨å¯å˜é«˜åº¦å¤„ç†å¤§é‡ç±»å‹
        //             const columnHeight = baseHeight - 100;

        //             // è®¡ç®—å‚ç›´é—´è· - å¢åŠ é—´éš”å› å­1.5ä½¿åœ†åœˆé—´è·æ›´å¤§
        //             // å…è®¸æœ€å¤§ä½¿ç”¨åˆ—é«˜åº¦çš„85%ï¼Œè¿™æ ·ä¸Šä¸‹éƒ½ä¼šç•™å‡ºç©ºé—´
        //             const totalGroupHeight = Math.min(columnHeight * 0.85, group.length * 60);
        //             const verticalSpacing = group.length > 1 ? totalGroupHeight / (group.length - 1) : 0;

        //             // ç¡®ä¿ç¬¬ä¸€åˆ—ï¼ˆæˆ‘çš„ç±»å‹ï¼‰å±…ä¸­æ˜¾ç¤º
        //             let startY = 0;
        //             if (diffIndex === 0) {
        //                 startY = columnHeight / 2; // å±…ä¸­
        //             } else {
        //                 // è®¡ç®—èµ·å§‹ä½ç½®ä»¥å±…ä¸­æ•´ç»„èŠ‚ç‚¹
        //                 startY = (columnHeight - totalGroupHeight) / 2;
        //             }

        //             // æ›´æ–°å¸ƒå±€ - æ ¹æ®ç»„å†…é¡¹ç›®æ•°é‡è‡ªåŠ¨è°ƒæ•´åˆ†å¸ƒ
        //             group.forEach((typeInfo, typeIndex) => {
        //                 // è®¡ç®—Yåæ ‡ - è‡ªåŠ¨åœ¨å¯ç”¨ç©ºé—´å†…å‡åŒ€åˆ†å¸ƒ
        //                 let nodeY;
        //                 if (group.length === 1) {
        //                     nodeY = columnHeight / 2; // å•ä¸ªèŠ‚ç‚¹å±…ä¸­
        //                 } else {
        //                     nodeY = startY + typeIndex * verticalSpacing;
        //                 }
        //                 const nodeX = diffIndex * columnWidth + columnWidth / 2;

        //                 // è®¾ç½®èŠ‚ç‚¹ä½ç½®
        //                 typeInfo.x = nodeX;
        //                 typeInfo.y = nodeY + 20;
        //             });
        //         }

        //         // é¦–å…ˆç»˜åˆ¶æ‰€æœ‰åœ†åœˆ
        //         groupedTypes.forEach((group, diffIndex) => {
        //             group.forEach((typeInfo) => {
        //                 const nodeSize = calculateNodeSize(typeInfo.ratio);
        //                 const isMyType = typeInfo.type === MyMBTI;

        //                 // åˆ›å»ºèŠ‚ç‚¹ç»„
        //                 const nodeGroup = g.append('g')
        //                     .attr('class', `mbti-node-group diff-${diffIndex}`);

        //                 // ç»˜åˆ¶åœ†åœˆ - ä½¿ç”¨å•ä¸€é¢œè‰²
        //                 nodeGroup.append('circle')
        //                     .attr('class', `mbti-node diff-${diffIndex}`)
        //                     .attr('cx', typeInfo.x)
        //                     .attr('cy', typeInfo.y)
        //                     .attr('r', nodeSize / 1.5)
        //                     .attr('fill', isMyType ? 'transparent' : '#D0D0D0') // è‡ªå·±çš„ç±»å‹ä½¿ç”¨é€æ˜å¡«å……ï¼Œå…¶ä»–ç±»å‹ä½¿ç”¨ç°è‰²
        //                     .attr('fill-opacity', 0.7)
        //                     .attr('stroke', isMyType ? '#fff' : 'rgba(255,255,255,0.5)')
        //                     .attr('stroke-width', isMyType ? 2 : 1)
        //                     .attr('filter', 'url(#glow)')
        //                     .style('transition', 'all 0.3s ease')
        //                     .on('mouseover', function () {
        //                         // æ˜¾ç¤ºç™¾åˆ†æ¯”æ ‡ç­¾
        //                         d3.select(`#percent-${typeInfo.type}`)
        //                             .style('opacity', 1);
        //                     })
        //                     .on('mouseout', function () {
        //                         // éšè—ç™¾åˆ†æ¯”æ ‡ç­¾
        //                         d3.select(`#percent-${typeInfo.type}`)
        //                             .style('opacity', 0);
        //                     });
        //                 // å¦‚æœæ˜¯æˆ‘çš„ç±»å‹ï¼ˆisMyTypeï¼‰ï¼Œåˆ™ç›´æ¥åœ¨åœ†åœˆå†…æ·»åŠ æ˜Ÿæ˜Ÿ
        //                 if (isMyType) {
        //                     // æ˜Ÿæ˜Ÿå¤§å°æ ¹æ®èŠ‚ç‚¹æ¯”ä¾‹å˜åŒ–
        //                     const starSize = Math.max(5, nodeSize);
        //                     nodeGroup.append('text')
        //                         .attr('x', typeInfo.x)
        //                         .attr('y', typeInfo.y)
        //                         .attr('text-anchor', 'middle')
        //                         .attr('dominant-baseline', 'central') // ä½¿æ˜Ÿæ˜Ÿå±…ä¸­
        //                         .attr('font-size', `${starSize}px`)
        //                         .attr('fill', groupColor) // é‡‘è‰²æ˜Ÿæ˜Ÿ
        //                         .attr('filter', 'url(#glow)')
        //                         .text('â˜…') // å®å¿ƒæ˜Ÿæ˜Ÿç¬¦å·
        //                         .on('mouseover', function () {
        //                             // æ˜¾ç¤ºç™¾åˆ†æ¯”æ ‡ç­¾
        //                             d3.select(`#percent-${typeInfo.type}`)
        //                                 .style('opacity', 1);
        //                         })
        //                         .on('mouseout', function () {
        //                             // éšè—ç™¾åˆ†æ¯”æ ‡ç­¾
        //                             d3.select(`#percent-${typeInfo.type}`)
        //                                 .style('opacity', 0);
        //                         });
        //                 }
        //             });
        //         });

        //         function drawBottomGroupLabels(typeGroups) {
        //             // è·å–åˆ—å®½ï¼Œä¸åˆ—æ ‡é¢˜ä¸€è‡´
        //             const columnWidth = (baseWidth - marginLeft - 40) / 5;

        //             // è®¡ç®—åº•éƒ¨æ ‡ç­¾çš„Yä½ç½® - åœ¨å›¾è¡¨åº•éƒ¨
        //             const bottomY = baseHeight - 390; // è·ç¦»åº•éƒ¨25åƒç´ 

        //             // åˆ›å»ºåº•éƒ¨æ ‡ç­¾åˆ†ç»„
        //             const bottomGroup = svg.append('g')
        //                 .attr('class', 'bottom-labels')
        //                 .attr('transform', `translate(${marginLeft}, ${bottomY})`);

        //             // æ·»åŠ åˆ†ç»„æŒ‡ç¤ºå™¨å’Œæ ‡ç­¾
        //             typeGroups.forEach((group, index) => {
        //                 // è®¡ç®—æ¯ä¸ªåˆ†ç»„æ ‡ç­¾çš„Xä½ç½®ï¼Œå‡åŒ€åˆ†å¸ƒ
        //                 const labelX = (index + 0.5) * ((baseWidth - marginLeft) / typeGroups.length) - 40;

        //                 // æ·»åŠ åˆ†ç»„æ–‡å­—æ ‡ç­¾
        //                 bottomGroup.append('text')
        //                     .attr('x', labelX + 5)
        //                     .attr('y', 0)
        //                     .attr('dy', '0.35em')
        //                     .attr('text-anchor', 'start')
        //                     .attr('font-size', '11px')
        //                     .attr('font-weight', 'bold')
        //                     .attr('fill', group.color)
        //                     .text("-- " + group.name);
        //             });
        //         }

        //         function drawTypeRelationships() {
        //             // æ”¶é›†æ‰€æœ‰ç±»å‹
        //             const nonZeroTypes = [];
        //             groupedTypes.forEach(group => {
        //                 group.forEach(typeInfo => {
        //                     nonZeroTypes.push(typeInfo);
        //                 });
        //             });

        //             // åˆ›å»ºè¿çº¿åˆ†ç»„ - æ”¾åœ¨æœ€åº•å±‚
        //             const linkGroup = g.append('g')
        //                 .attr('class', 'mbti-links')
        //                 .lower(); // ç¡®ä¿åœ¨åœ†åœˆä¸‹æ–¹

        //             // å…ˆç»˜åˆ¶æ‰€æœ‰åˆ†ç»„çš„è¿çº¿ç½‘ç»œ
        //             typeGroups.forEach(group => {
        //                 // æ‰¾å‡ºå½“å‰åˆ†ç»„ä¸­çš„æ‰€æœ‰ç±»å‹
        //                 const groupTypes = nonZeroTypes.filter(t => group.types.includes(t.type));

        //                 if (groupTypes.length >= 2) {
        //                     // ä½¿ç”¨æœ€å°ç”Ÿæˆæ ‘ç®—æ³•ï¼Œé¿å…è¿‡å¤šäº¤å‰çº¿
        //                     const connections = buildMinimumSpanningTree(groupTypes);

        //                     // ç»˜åˆ¶è¿çº¿
        //                     // connections.forEach(conn => {
        //                     //     linkGroup.append('path')
        //                     //         .attr('d', `M ${conn.source.x} ${conn.source.y} L ${conn.target.x} ${conn.target.y}`)
        //                     //         .attr('stroke', group.lineColor)
        //                     //         .attr('stroke-width', 1.5)
        //                     //         .attr('stroke-opacity', 1)
        //                     //         .attr('stroke-dasharray', '5,3')
        //                     //         .attr('fill', 'none')
        //                     //         .lower();
        //                     // });
        //                 }
        //             });

        //             // ä¸ºæ¯ä¸ªMBTIç±»å‹æ·»åŠ åˆ†ç»„æŒ‡ç¤ºå™¨ - åœ†ç¯
        //             nonZeroTypes.forEach(typeInfo => {
        //                 // æ‰¾å‡ºç±»å‹æ‰€å±åˆ†ç»„
        //                 const group = typeGroups.find(g => g.types.includes(typeInfo.type));
        //                 if (group) {
        //                     const nodeSize = calculateNodeSize(typeInfo.ratio);

        //                     // æ·»åŠ åˆ†ç»„æŒ‡ç¤ºç¯
        //                     // linkGroup.append('circle')
        //                     //     .attr('cx', typeInfo.x)
        //                     //     .attr('cy', typeInfo.y)
        //                     //     .attr('r', nodeSize * 0.7)
        //                     //     .attr('fill', 'none')
        //                     //     .attr('stroke', group.lineColor)
        //                     //     .attr('stroke-width', 1.5)
        //                     //     .attr('stroke-opacity', 1)
        //                     //     .lower();
        //                 }
        //             });
        //             drawBottomGroupLabels(typeGroups);
        //         }

        //         // æ„å»ºæœ€å°ç”Ÿæˆæ ‘ - ç”¨äºè¿æ¥åŒç»„å†…çš„MBTIç±»å‹
        //         function buildMinimumSpanningTree(nodes) {
        //             if (nodes.length < 2) return [];

        //             // è®¡ç®—æ‰€æœ‰ç‚¹å¯¹ä¹‹é—´çš„è·ç¦»
        //             const edges = [];
        //             for (let i = 0; i < nodes.length; i++) {
        //                 for (let j = i + 1; j < nodes.length; j++) {
        //                     const dx = nodes[i].x - nodes[j].x;
        //                     const dy = nodes[i].y - nodes[j].y;
        //                     const distance = Math.sqrt(dx * dx + dy * dy);
        //                     edges.push({
        //                         source: nodes[i],
        //                         target: nodes[j],
        //                         distance: distance
        //                     });
        //                 }
        //             }

        //             // æŒ‰è·ç¦»æ’åº
        //             edges.sort((a, b) => a.distance - b.distance);

        //             // Kruskalç®—æ³•æ„å»ºæœ€å°ç”Ÿæˆæ ‘
        //             const result = [];
        //             const sets = nodes.map((_, i) => i); // åˆå§‹æ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯å•ç‹¬çš„é›†åˆ

        //             // æŸ¥æ‰¾èŠ‚ç‚¹æ‰€åœ¨é›†åˆ
        //             function find(i) {
        //                 if (sets[i] !== i) {
        //                     sets[i] = find(sets[i]);
        //                 }
        //                 return sets[i];
        //             }

        //             // åˆå¹¶ä¸¤ä¸ªé›†åˆ
        //             function union(i, j) {
        //                 sets[find(i)] = find(j);
        //             }

        //             // æ·»åŠ è¾¹ï¼Œç›´åˆ°å½¢æˆæ ‘
        //             let edgeCount = 0;
        //             for (const edge of edges) {
        //                 const i = nodes.indexOf(edge.source);
        //                 const j = nodes.indexOf(edge.target);

        //                 if (find(i) !== find(j)) {
        //                     result.push(edge);
        //                     union(i, j);
        //                     edgeCount++;

        //                     // å½“è¾¹æ•°ç­‰äºèŠ‚ç‚¹æ•°-1æ—¶ï¼Œæœ€å°ç”Ÿæˆæ ‘å®Œæˆ
        //                     if (edgeCount === nodes.length - 1) {
        //                         break;
        //                     }
        //                 }
        //             }

        //             return result;
        //         }

        //         // è®¡ç®—ç‚¹é›†çš„ä¸­å¿ƒä½ç½®
        //         function calculateCentroid(points) {
        //             const sumX = points.reduce((sum, p) => sum + p.x, 0);
        //             const sumY = points.reduce((sum, p) => sum + p.y, 0);
        //             return {
        //                 x: sumX / points.length,
        //                 y: sumY / points.length
        //             };
        //         }

        //         // å°†åœ†åœˆå¤§å°æ”¾å¤§ä¸€äº›ï¼Œä½¿è§†è§‰æ•ˆæœæ›´æ˜æ˜¾
        //         function calculateNodeSize(ratio) {
        //             // å°äº1%çš„èŠ‚ç‚¹ä¹Ÿè¦æœ‰æœ€å°å°ºå¯¸
        //             if (ratio < 0.01) return 10;
        //             // ä½¿ç”¨å¹³æ–¹æ ¹æ¯”ä¾‹å°ºä»¥æ›´å¥½åœ°æ˜¾ç¤ºè¾ƒå°æ¯”ä¾‹
        //             return 10 + Math.sqrt(ratio * 100) * 4.5;
        //         }

        //         // 3. ç»˜åˆ¶ç±»å‹å…³ç³» - ç¡®ä¿æ‰€æœ‰ç»„éƒ½æ˜¾ç¤º
        //         drawTypeRelationships();

        //         // ç„¶åç»˜åˆ¶æ‰€æœ‰æ–‡å­—æ ‡ç­¾ï¼Œç¡®ä¿å®ƒä»¬åœ¨æ‰€æœ‰åœ†åœˆçš„ä¸Šæ–¹
        //         groupedTypes.forEach((group, diffIndex) => {
        //             group.forEach((typeInfo) => {
        //                 const nodeSize = calculateNodeSize(typeInfo.ratio);
        //                 const isMyType = typeInfo.type === MyMBTI;

        //                 // åˆ›å»ºæ–‡å­—åˆ†ç»„
        //                 const textGroup = g.append('g')
        //                     .attr('class', `mbti-text-group diff-${diffIndex}`);

        //                 // æ·»åŠ ç™¾åˆ†æ¯”æç¤ºæ–‡æœ¬
        //                 textGroup.append('text')
        //                     .attr('id', `percent-${typeInfo.type}`)
        //                     .attr('x', typeInfo.x)
        //                     .attr('y', typeInfo.y - nodeSize) // æ–‡æœ¬æ”¾åœ¨åœ†åœˆä¸Šæ–¹
        //                     .attr('text-anchor', 'middle')
        //                     .attr('font-size', '11px')
        //                     .attr('font-weight', 'bold')
        //                     .attr('fill', 'rgb(101, 78, 163)')
        //                     .attr('stroke', 'rgba(0,0,0,0.5)')
        //                     .attr('stroke-width', 0.5)
        //                     .style('opacity', 0)
        //                     .style('pointer-events', 'none')
        //                     .style('transition', 'opacity 0.3s ease')
        //                     .text(`${(typeInfo.ratio * 100).toFixed(1)}%`);

        //                 const labelText = textGroup.append('text')
        //                     .attr('class', 'mbti-label')
        //                     .attr('x', typeInfo.x)
        //                     .attr('y', typeInfo.y + nodeSize + 2)
        //                     .attr('text-anchor', 'middle')
        //                     .attr('dy', '0.35em')
        //                     .attr('font-size', '10px');

        //                 // åˆ†ææ¯ä¸ªå­—æ¯å¹¶æ·»åŠ é€‚å½“é¢œè‰²
        //                 labelText.text('');  // æ¸…ç©ºæ–‡æœ¬ä»¥æ·»åŠ å¸¦æ ¼å¼çš„å†…å®¹
        //                 for (let i = 0; i < 4; i++) {
        //                     const charMyType = MyMBTI[i];
        //                     const charThisType = typeInfo.type[i];
        //                     const isDifferent = charMyType !== charThisType;

        //                     labelText.append('tspan')
        //                         .text(charThisType)
        //                         .attr('text-decoration', isDifferent ? 'underline' : null);  // ä¸åŒçš„å­—æ¯åŠ ä¸‹åˆ’çº¿
        //                 }
        //             });
        //         });
        //     }

        //     // æ‰§è¡Œç»˜å›¾
        //     drawColumnHeaders();
        //     renderMBTICircles();
        // }
        function drawMBTIPerception(mbtiCounts) {
            // åŸºç¡€è®¾ç½® - è°ƒæ•´ä¸º400*400
            const baseWidth = 400;
            const baseHeight = 450;
            const margin = { top: 10, right: 20, bottom: 10, left: 10 };
            const width = baseWidth - margin.left - margin.right;
            const height = baseHeight - margin.bottom;

            // æ¸…ç©ºä¹‹å‰çš„å›¾è¡¨
            d3.select('#mbtiSankeyChart').selectAll('*').remove();

            // åˆ›å»ºSVG
            const svg = d3.select('#mbtiSankeyChart')
                .append('svg')
                .attr('width', baseWidth)
                .attr('height', baseHeight)
                .style('font-family', 'Poppins, sans-serif')
                .attr('viewBox', `0 0 ${baseWidth} ${baseHeight}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            // ä¸»ç»˜å›¾åŒºåŸŸ
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // è·å–ç”¨æˆ·è‡ªå·±çš„MBTIç±»å‹
            const MyMBTI = (new URLSearchParams(window.location.search).get('mbti') || 'INFP').toUpperCase();

            // åˆ›å»ºæ‰€æœ‰å¯èƒ½çš„MBTIç±»å‹åˆ—è¡¨
            const allTypes = ['ISTJ', 'ISFJ', 'INFJ', 'INTJ', 'ISTP', 'ISFP', 'INFP', 'INTP', 'ESTP', 'ESFP', 'ENFP', 'ENTP', 'ESTJ', 'ESFJ', 'ENFJ', 'ENTJ'];

            // è®¡ç®—æ€»æ•°å’Œå…¶ä»–ç»Ÿè®¡
            let total = 0;
            for (const type of allTypes) {
                total += mbtiCounts[type] || 0;
            }

            // æ±‰æ˜è·ç¦»è®¡ç®—å‡½æ•°
            function hammingDistance(a, b) {
                let distance = 0;
                for (let i = 0; i < 4; i++) {
                    if (a[i] !== b[i]) distance++;
                }
                return distance;
            }

            // å‡†å¤‡æ‰€æœ‰ç±»å‹çš„æ•°æ®ï¼ŒåŒ…å«å·®å¼‚ç¨‹åº¦å’Œå…¨å±€æ’å
            const allTypesData = [];
            allTypes.forEach(type => {
                const count = mbtiCounts[type] || 0;
                // åªæ·»åŠ æœ‰äººè®¤ä¸ºçš„ç±»å‹
                if (count > 0) {
                    allTypesData.push({
                        type: type,
                        count: count,
                        percentage: (count / total) * 100,
                        diff: hammingDistance(type, MyMBTI)
                    });
                }
            });

            // å…¨å±€æ’åº - æŒ‰ç…§ç™¾åˆ†æ¯”ä»å¤§åˆ°å°
            allTypesData.sort((a, b) => b.percentage - a.percentage);

            // è·å–å‰ä¸‰å
            const topThree = allTypesData.slice(0, 3);

            // æŒ‰ç…§æ’åºåçš„é¡ºåºåˆ†é…å…¨å±€æ’åï¼Œç›¸åŒç™¾åˆ†æ¯”çš„ä¿æŒç›¸åŒæ’å
            let currentRank = 1;
            let previousPercentage = -1;
            allTypesData.forEach((item, index) => {
                if (index === 0 || item.percentage !== previousPercentage) {
                    currentRank = index + 1;
                }
                item.globalRank = currentRank;
                previousPercentage = item.percentage;
            });

            // æ‰¾å‡ºæœ€å¤§å’Œæœ€å°ç™¾åˆ†æ¯”ï¼Œç”¨äºé¢œè‰²æ¯”ä¾‹å°º
            const maxPercentage = allTypesData.length > 0 ? allTypesData[0].percentage : 0;
            const minPercentage = allTypesData.length > 0 ? allTypesData[allTypesData.length - 1].percentage : 0;

            // åˆ†ç»„MBTIç±»å‹ï¼ˆæŒ‰å·®å¼‚ç¨‹åº¦ï¼‰
            const groupedByDiff = [[], [], [], [], []];
            allTypesData.forEach(item => {
                groupedByDiff[item.diff].push(item);
            });

            // åˆ›å»ºæ›´ä¼˜é›…çš„é¢œè‰²æ¯”ä¾‹å°º
            const colorScale = d3.scaleLinear()
                .domain([minPercentage, maxPercentage])
                .range(['#f4f1fa', '#d8b4fe']);  // ä»æ·¡ç´«è‰²åˆ°æ·±ç´«è‰²

            // åˆ›å»ºå·¥å…·æç¤º
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0)
                .style('position', 'absolute')
                .style('padding', '10px')
                .style('background', 'white')
                .style('border-radius', '6px')
                .style('pointer-events', 'none')
                .style('box-shadow', '0 4px 12px rgba(0,0,0,0.15)')
                .style('font-size', '12px')
                .style('max-width', '180px')
                .style('z-index', 100);

            // è®¾ç½®è¡Œé«˜å¹¶ä¿®æ­£diffæ ‡ç­¾ä½ç½®
            const rowHeight = 80;

            // ç»˜åˆ¶æ¡†å’Œæ ‡é¢˜ï¼Œç¡®ä¿diffæ ‡ç­¾ä¸è¢«é®æŒ¡
            for (let i = 0; i < 5; i++) {
                const boxY = i * rowHeight + 40;
                const boxHeight = rowHeight - 8;

                // ç»˜åˆ¶è™šçº¿æ¡† 
                g.append('rect')
                    .attr('x', 0)
                    .attr('y', boxY)
                    .attr('width', width)
                    .attr('height', boxHeight)
                    .attr('fill', 'none')
                    .attr('stroke', '#ddd')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '3,3')
                    .attr('rx', 8)
                    .attr('ry', 8);

                // ç»˜åˆ¶æ¡†æ ‡ç­¾ - ç§»åˆ°å·¦ä¸Šè§’ï¼Œé¿å…é‡å 
                g.append('text')
                    .attr('x', 10)
                    .attr('y', boxY + 18)
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .attr('fill', '#555')
                    .text(`${i} diff${i !== 1 ? 's' : ''}`);

                // è®¡ç®—è¿™ä¸ªæ¡†å†…çš„åœ†å½¢
                const items = groupedByDiff[i];
                if (items.length === 0) {
                    // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæ·»åŠ æç¤ºæ–‡æœ¬
                    g.append('text')
                        .attr('x', width / 2)
                        .attr('y', boxY + boxHeight / 2)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .attr('font-size', '12px')
                        .attr('fill', '#aaa')
                        .text('No perceptions in this category');
                    continue;
                }

                const maxItems = items.length;
                const circleMaxRadius = 25; // è¾ƒå¤§çš„åœ†å½¢
                const circleMinRadius = 12; // è¾ƒå°çš„åœ†å½¢çš„æœ€å°åŠå¾„
                const circleCenterY = boxY + boxHeight / 2;

                // è®¡ç®—åœ†å½¢é—´è·
                const circleSpacing = (width - 200) / Math.max(maxItems - 1, 1);

                // ä¸ºæ¯ä¸ªé¡¹ç›®åˆ›å»ºåœ†å½¢
                items.forEach((item, index) => {
                    // è®¡ç®—åœ†å½¢çš„ä½ç½® - å‡åŒ€åˆ†å¸ƒ
                    const circleX = 100 + index * circleSpacing;

                    // æ ¹æ®ç™¾åˆ†æ¯”ç¡®å®šåœ†å½¢å¤§å°
                    const percentage = item.percentage / maxPercentage;
                    const radius = circleMinRadius + (circleMaxRadius - circleMinRadius) * percentage;

                    // ç¡®å®šæ˜¯å¦åœ¨å‰ä¸‰å
                    const isTopThree = item.globalRank <= 3;

                    // åœ†å½¢é¢œè‰²è®¾ç½®
                    let fillColor, strokeColor, strokeWidth;

                    if (item.type === MyMBTI) {
                        // ç”¨æˆ·è‡ªå·±çš„ç±»å‹ - ä½¿ç”¨æ·¡é»„è‰²
                        fillColor = groupColor + 66;
                        strokeColor = groupColor;
                        strokeWidth = 2;
                    } else if (isTopThree) {
                        // å‰ä¸‰åä½¿ç”¨ç´«è‰²ç³»æ¸å˜
                        fillColor = d3.interpolate('#f0e6fa', colorScale(item.percentage))(0.7);
                        strokeColor = colorScale(item.percentage);
                        strokeWidth = 2;
                    } else {
                        // å…¶ä»–æ’åä½¿ç”¨æ·¡è‰²å¡«å……
                        fillColor = '#f8f9fa';
                        strokeColor = '#adb5bd';
                        strokeWidth = 1.5;
                    }

                    // ç»˜åˆ¶åœ†å½¢é˜´å½±
                    g.append('circle')
                        .attr('cx', circleX)
                        .attr('cy', circleCenterY + 2)
                        .attr('r', radius)
                        .attr('fill', 'rgba(0,0,0,0.05)')
                        .attr('stroke', 'none');

                    // ç»˜åˆ¶ä¸»åœ†å½¢
                    const circle = g.append('circle')
                        .attr('cx', circleX)
                        .attr('cy', circleCenterY)
                        .attr('r', radius)
                        .attr('fill', fillColor)
                        .attr('stroke', strokeColor)
                        .attr('stroke-width', strokeWidth)
                        .style('cursor', 'pointer')
                        .style('transition', 'all 0.2s ease');

                    // æ·»åŠ åœ†å½¢å†…çš„æ–‡æœ¬ - MBTIç±»å‹
                    g.append('text')
                        .attr('x', circleX)
                        .attr('y', circleCenterY - 2)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .attr('font-size', radius < 20 ? '7px' : '11px')
                        .attr('font-weight', 'bold')
                        .attr('fill', item.type === MyMBTI ? groupColor : '#444')
                        .text(item.type);

                    // æ·»åŠ ç™¾åˆ†æ¯”æ–‡æœ¬

                    // ä¸ºå‰ä¸‰åæ·»åŠ å¥–ç‰Œæ ‡è®° - æ”¾åœ¨å³ä¸Šæ–¹ï¼Œä¸é®æŒ¡æ–‡å­—
                    if (isTopThree) {
                        const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];

                        g.append('text')
                            .attr('x', circleX + radius * 0.65)
                            .attr('y', circleCenterY - radius * 0.65)
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '11px')
                            .text(medals[item.globalRank - 1]);
                    }

                    // æ·»åŠ äº¤äº’æ•ˆæœ
                    circle.on('mouseover', function (event) {
                        // æ”¾å¤§æ•ˆæœ
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr('r', radius * 1.08)
                            .attr('stroke-width', strokeWidth + 0.5);

                        // æ˜¾ç¤ºè¯¦ç»†æç¤º
                        let tooltipHTML = `
                    <div style="text-align:center;">
                        <div style="font-weight:bold;font-size:14px;margin-bottom:3px;">${item.type}</div>
                        <div style="font-size:12px;">${item.count} votes (${item.percentage.toFixed(1)}%)</div>
                        <div style="margin-top:5px;font-size:11px;color:#666;">
                            ${item.diff} letter${item.diff !== 1 ? 's' : ''} different from ${MyMBTI}
                        </div>
                `;

                        // ä¸ºå‰ä¸‰åæ·»åŠ é¢å¤–ä¿¡æ¯
                        if (isTopThree) {
                            const rankTexts = ['1st', '2nd', '3rd'];
                            tooltipHTML += `
                        <div style="margin-top:6px;padding-top:6px;border-top:1px solid #eee;">
                            <span style="color:#9333ea;font-weight:bold;">${rankTexts[item.globalRank - 1]}</span> 
                            <span style="font-size:11px;color:#666;">most common perception</span>
                        </div>
                    `;
                        }

                        tooltipHTML += '</div>';

                        tooltip.html(tooltipHTML)
                            .style('opacity', 1)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                        .on('mouseout', function () {
                            // æ¢å¤åŸå§‹å¤§å°
                            d3.select(this)
                                .transition()
                                .duration(200)
                                .attr('r', radius)
                                .attr('stroke-width', strokeWidth);

                            // éšè—æç¤ºæ¡†
                            tooltip.style('opacity', 0);
                        });
                });
            }

            // åˆ›å»ºé¡¶éƒ¨æ ‡é¢˜
            svg.append('text')
                .attr('x', baseWidth / 2)
                .attr('y', 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', '16px')
                .attr('font-weight', 'bold')
                .attr('fill', '#333')
                .text('How Others Perceive Your MBTI Type');

            // æ·»åŠ å‰ä¸‰åçš„çªå‡ºæ˜¾ç¤ºè¯´æ˜ - ç¡®ä¿æ–‡å­—ä¸é‡å 
            const topThreeText = topThree.length > 0
                ? `Top perceptions: ${topThree.map(t => t.type).join(', ')}`
                : '';

            if (topThreeText) {
                svg.append('text')
                    .attr('x', baseWidth / 2)
                    .attr('y', 38)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '11px')
                    .attr('fill', '#666')
                    .text(topThreeText);
            }

            // æ·»åŠ ç®€æ´çš„å›¾ä¾‹ - ç§»åˆ°å³ä¸Šè§’ï¼Œé¿å…é®æŒ¡
            const legend = svg.append('g')
                .attr('transform', `translate(${baseWidth - 100}, 50)`);

            // æ·»åŠ "Your type"å›¾ä¾‹
            legend.append('circle')
                .attr('cx', 6)
                .attr('cy', 10)
                .attr('r', 6)
                .attr('fill', groupColor + 66)
                .attr('stroke', groupColor)
                .attr('stroke-width', 1.5);

            legend.append('text')
                .attr('x', 16)
                .attr('y', 13)
                .attr('font-size', '9px')
                .attr('fill', '#666')
                .text('Your type');

            // æ·»åŠ "Top 3"å›¾ä¾‹
            legend.append('circle')
                .attr('cx', 6)
                .attr('cy', 28)
                .attr('r', 6)
                .attr('fill', '#f0e6fa')
                .attr('stroke', '#a855f7')
                .attr('stroke-width', 1.5);

            legend.append('text')
                .attr('x', 16)
                .attr('y', 31)
                .attr('font-size', '9px')
                .attr('fill', '#666')
                .text('Top 3');

            // æ·»åŠ "Others"å›¾ä¾‹
            legend.append('circle')
                .attr('cx', 6)
                .attr('cy', 46)
                .attr('r', 6)
                .attr('fill', '#f8f9fa')
                .attr('stroke', '#adb5bd')
                .attr('stroke-width', 1.5);

            legend.append('text')
                .attr('x', 16)
                .attr('y', 49)
                .attr('font-size', '9px')
                .attr('fill', '#666')
                .text('Others');
        }
        // function drawMBTIPerception(mbtiCounts) {
        //     // åŸºç¡€è®¾ç½® - è°ƒæ•´ä¸º400*400
        //     const baseWidth = 400;
        //     const baseHeight = 400;
        //     const margin = { top: 40, right: 20, bottom: 30, left: 20 };
        //     const width = baseWidth - margin.left - margin.right;
        //     const height = baseHeight - margin.top - margin.bottom;

        //     // æ¸…ç©ºä¹‹å‰çš„å›¾è¡¨
        //     d3.select('#mbtiSankeyChart').selectAll('*').remove();

        //     // åˆ›å»ºSVG
        //     const svg = d3.select('#mbtiSankeyChart')
        //         .append('svg')
        //         .attr('width', baseWidth)
        //         .attr('height', baseHeight)
        //         .style('font-family', 'Poppins, sans-serif')
        //         .attr('viewBox', `0 0 ${baseWidth} ${baseHeight}`)
        //         .attr('preserveAspectRatio', 'xMidYMid meet');

        //     // ä¸»ç»˜å›¾åŒºåŸŸ
        //     const g = svg.append('g')
        //         .attr('transform', `translate(${margin.left},${margin.top})`);

        //     // è·å–ç”¨æˆ·è‡ªå·±çš„MBTIç±»å‹
        //     const MyMBTI = (new URLSearchParams(window.location.search).get('mbti') || 'INFP').toUpperCase();

        //     // åˆ›å»ºæ‰€æœ‰å¯èƒ½çš„MBTIç±»å‹åˆ—è¡¨
        //     const allTypes = ['ISTJ', 'ISFJ', 'INFJ', 'INTJ', 'ISTP', 'ISFP', 'INFP', 'INTP', 'ESTP', 'ESFP', 'ENFP', 'ENTP', 'ESTJ', 'ESFJ', 'ENFJ', 'ENTJ'];

        //     // è®¡ç®—æ€»æ•°å’Œå…¶ä»–ç»Ÿè®¡
        //     let total = 0;
        //     for (const type of allTypes) {
        //         total += mbtiCounts[type] || 0;
        //     }

        //     // æ±‰æ˜è·ç¦»è®¡ç®—å‡½æ•°
        //     function hammingDistance(a, b) {
        //         let distance = 0;
        //         for (let i = 0; i < 4; i++) {
        //             if (a[i] !== b[i]) distance++;
        //         }
        //         return distance;
        //     }

        //     // æŒ‰ç…§å·®å¼‚ç¨‹åº¦åˆ†ç»„
        //     const groupedByDiff = [[], [], [], [], []];

        //     // åˆ†ç±»æ‰€æœ‰MBTIç±»å‹
        //     allTypes.forEach(type => {
        //         const diff = hammingDistance(type, MyMBTI);
        //         const count = mbtiCounts[type] || 0;

        //         // åªæ·»åŠ æœ‰äººè®¤ä¸ºçš„ç±»å‹
        //         if (count > 0) {
        //             groupedByDiff[diff].push({
        //                 type: type,
        //                 count: count,
        //                 percentage: (count / total) * 100,
        //                 diff: diff
        //             });
        //         }
        //     });

        //     // åœ¨æ¯ç»„å†…æŒ‰æ•°é‡æ’åº
        //     groupedByDiff.forEach(group => {
        //         group.sort((a, b) => b.count - a.count);
        //     });

        //     // ç®€åŒ–çš„æ¡†æ ‡é¢˜
        //     const boxTitles = [
        //         "0 diff",
        //         "1 diff",
        //         "2 diffs",
        //         "3 diffs",
        //         "4 diffs"
        //     ];

        //     // æ¡†çš„å®½åº¦ï¼ˆè¾ƒä¸ºå¹³å‡ï¼‰
        //     const boxWidth = width / 5 - 5; // 5pxå·¦å³é—´è·

        //     // è®¡ç®—æ¡†çš„ä½ç½® (å‚ç›´æ’åˆ—5è¡Œ)
        //     const boxPositions = [];
        //     const rowHeight = height / 5;

        //     for (let i = 0; i < 5; i++) {
        //         boxPositions.push({
        //             x: 0,
        //             y: i * rowHeight,
        //             width: width,
        //             height: rowHeight - 10 // 10pxä¸Šä¸‹é—´è·
        //         });
        //     }

        //     // ç»˜åˆ¶æ¡†å’Œæ ‡é¢˜
        //     for (let i = 0; i < 5; i++) {
        //         const box = boxPositions[i];

        //         // ç»˜åˆ¶è™šçº¿æ¡†
        //         g.append('rect')
        //             .attr('x', box.x)
        //             .attr('y', box.y)
        //             .attr('width', box.width)
        //             .attr('height', box.height)
        //             .attr('fill', 'none')
        //             .attr('stroke', '#aaa')
        //             .attr('stroke-width', 1)
        //             .attr('stroke-dasharray', '3,3')
        //             .attr('rx', 3)
        //             .attr('ry', 3);

        //         // ç»˜åˆ¶æ¡†æ ‡é¢˜
        //         g.append('text')
        //             .attr('x', 5)
        //             .attr('y', box.y + 15)
        //             .attr('font-size', '10px')
        //             .attr('font-weight', 'bold')
        //             .text(boxTitles[i]);

        //         // è®¡ç®—è¿™ä¸ªæ¡†å†…çš„çŸ©å½¢
        //         const items = groupedByDiff[i];
        //         if (items.length === 0) continue;

        //         // æ‰¾å‡ºè¿™ç»„ä¸­æœ€å¤§çš„å€¼ï¼Œç”¨äºç¼©æ”¾
        //         const maxCount = Math.max(...items.map(item => item.count));

        //         // æ°´å¹³æ’åˆ—çŸ©å½¢
        //         const rectHeight = box.height * 0.6;
        //         const maxItems = Math.min(items.length, 8); // é™åˆ¶æ¯è¡Œæœ€å¤š8ä¸ªçŸ©å½¢
        //         const rectSpacing = 5;
        //         const rectWidth = Math.min((box.width - 60) / maxItems - rectSpacing, 45);

        //         // ä¸ºæ¯ä¸ªé¡¹ç›®åˆ›å»ºçŸ©å½¢
        //         items.forEach((item, index) => {
        //             if (index >= maxItems) return; // é™åˆ¶æ˜¾ç¤ºæ•°é‡

        //             // è®¡ç®—çŸ©å½¢çš„ä½ç½®
        //             const rectX = 60 + index * (rectWidth + rectSpacing);
        //             const rectY = box.y + (box.height - rectHeight) / 2;

        //             // è®¡ç®—å¤§å°ç¼©æ”¾ï¼ˆæ ¹æ®æ•°é‡ï¼‰
        //             const scale = 0.3 + 0.7 * (item.count / maxCount);
        //             const adjustedHeight = rectHeight * scale;

        //             // ç»˜åˆ¶çŸ©å½¢
        //             g.append('rect')
        //                 .attr('x', rectX)
        //                 .attr('y', rectY + (rectHeight - adjustedHeight) / 2)
        //                 .attr('width', rectWidth)
        //                 .attr('height', adjustedHeight)
        //                 .attr('fill', item.type === MyMBTI ? '#ffeb3b' : '#f0f0f0') // è‡ªå·±çš„ç±»å‹ç”¨é»„è‰²
        //                 .attr('stroke', '#666')
        //                 .attr('stroke-width', 1)
        //                 .attr('rx', 2)
        //                 .attr('ry', 2)
        //                 .style('opacity', 0.8)
        //                 .on('mouseover', function (event) {
        //                     // é¼ æ ‡æ‚¬åœæ•ˆæœ
        //                     d3.select(this).style('opacity', 1);

        //                     // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
        //                     tooltip.style('opacity', 1)
        //                         .html(`<strong>${item.type}</strong><br>${item.count} votes (${item.percentage.toFixed(1)}%)`)
        //                         .style('left', (d3.event.pageX + 5) + 'px')
        //                         .style('top', (d3.event.pageY - 10) + 'px');
        //                 })
        //                 .on('mouseout', function () {
        //                     d3.select(this).style('opacity', 0.8);
        //                     tooltip.style('opacity', 0);
        //                 });

        //             // åœ¨çŸ©å½¢å†…éƒ¨æ·»åŠ MBTIæ ‡ç­¾
        //             g.append('text')
        //                 .attr('x', rectX + rectWidth / 2)
        //                 .attr('y', rectY + (rectHeight - adjustedHeight) / 2 + adjustedHeight / 2 - 5)
        //                 .attr('text-anchor', 'middle')
        //                 .attr('font-size', '8px')
        //                 .attr('font-weight', 'bold')
        //                 .text(item.type);

        //             // æ·»åŠ ç™¾åˆ†æ¯”ä¿¡æ¯
        //             g.append('text')
        //                 .attr('x', rectX + rectWidth / 2)
        //                 .attr('y', rectY + (rectHeight - adjustedHeight) / 2 + adjustedHeight / 2 + 8)
        //                 .attr('text-anchor', 'middle')
        //                 .attr('font-size', '7px')
        //                 .text(`${item.percentage.toFixed(0)}%`);

        //             // æ·»åŠ åæ¬¡æ ‡ç­¾ï¼ˆä»…å¯¹æ¯ç»„å‰ä¸‰ï¼‰
        //             if (index < 3 && items.length > 1) {
        //                 const medals = ['1st', '2nd', '3rd'];
        //                 const medalColors = ['#FFD700', '#C0C0C0', '#CD7F32']; // Gold, Silver, Bronze

        //                 g.append('text')
        //                     .attr('x', rectX + rectWidth - 2)
        //                     .attr('y', rectY + (rectHeight - adjustedHeight) / 2 + 7)
        //                     .attr('text-anchor', 'end')
        //                     .attr('font-size', '6px')
        //                     .attr('font-weight', 'bold')
        //                     .attr('fill', medalColors[index])
        //                     .text(medals[index]);
        //             }
        //         });
        //     }

        //     // åˆ›å»ºå›¾è¡¨æ ‡é¢˜
        //     svg.append('text')
        //         .attr('x', baseWidth / 2)
        //         .attr('y', 15)
        //         .attr('text-anchor', 'middle')
        //         .attr('font-size', '12px')
        //         .attr('font-weight', 'bold')
        //         .text('How Others Perceive Your MBTI Type');

        //     // æ·»åŠ è‡ªå·±çš„ç±»å‹ä¿¡æ¯
        //     svg.append('text')
        //         .attr('x', baseWidth / 2)
        //         .attr('y', baseHeight - 5)
        //         .attr('text-anchor', 'middle')
        //         .attr('font-size', '10px')
        //         .text(`Your Type: ${MyMBTI}`);

        //     // åˆ›å»ºå·¥å…·æç¤º
        //     const tooltip = d3.select('body').append('div')
        //         .attr('class', 'tooltip')
        //         .style('opacity', 0)
        //         .style('position', 'absolute')
        //         .style('padding', '5px')
        //         .style('background', 'white')
        //         .style('border', '1px solid #ddd')
        //         .style('border-radius', '2px')
        //         .style('pointer-events', 'none')
        //         .style('font-size', '10px')
        //         .style('z-index', 100);

        //     // åˆ›å»ºç®€åŒ–å›¾ä¾‹
        //     const legend = svg.append('g')
        //         .attr('transform', `translate(${baseWidth - 65}, 10)`);

        //     // å›¾ä¾‹é¡¹ç›® - æˆ‘çš„ç±»å‹
        //     legend.append('rect')
        //         .attr('x', 0)
        //         .attr('y', 0)
        //         .attr('width', 8)
        //         .attr('height', 8)
        //         .attr('fill', '#ffeb3b');

        //     legend.append('text')
        //         .attr('x', 12)
        //         .attr('y', 7)
        //         .attr('font-size', '6px')
        //         .text('Your type');

        //     // å›¾ä¾‹é¡¹ç›® - å…¶ä»–ç±»å‹
        //     legend.append('rect')
        //         .attr('x', 0)
        //         .attr('y', 12)
        //         .attr('width', 8)
        //         .attr('height', 8)
        //         .attr('fill', '#f0f0f0');

        //     legend.append('text')
        //         .attr('x', 12)
        //         .attr('y', 19)
        //         .attr('font-size', '6px')
        //         .text('Others');
        // }


        function onFilterChange(e) {
            updateSelectDisabling(e.target.id);
            updateCombinedRadar();
        }
        // 1. æ­£ç¡®çš„å·®å¼‚è®¡ç®—å‡½æ•°
        function getDimensionDiff(base, other) {
            let diff = 0;
            for (let i = 0; i < 4; i++) {
                if (base[i] !== other[i]) diff++;
            }
            return diff;
        }
        const filterConfigs = [
            { key: 'relationshipType', selectId: 'filterRelType' },
            { key: 'sinceWhen', selectId: 'filterSinceWhen' },
            // { key: 'familiarity', selectId: 'filterFamiliarity' },
            { key: 'interactionPlace', selectId: 'filterInteraction' }
        ];
        let combinedChart = null;

        // ç¦ç”¨å·²é€‰é¡¹äºå…¶å®ƒä¸‹æ‹‰æ¡†
        function updateSelectDisabling(changedId) {
            const sel = document.getElementById(changedId);
            const val = sel.value;
            filterConfigs.forEach(({ selectId }) => {
                if (selectId === changedId) return;
                const other = document.getElementById(selectId);
                Array.from(other.options).forEach(opt => {
                    opt.disabled = (opt.value === val && val !== 'all');
                    // å¦‚æœå½“å‰å€¼è¢«ç¦ï¼Œå°±é‡ç½®ä¸º all
                    if (opt.disabled && other.value === val) other.value = 'all';
                });
            });
        }
        let mbtiNetworkChart = null;


        function updateCombinedRadar() {
            // è®¡ç®—æ‰€æœ‰ç­›é€‰ç»„åˆçš„å‡†ç¡®åº¦
            const groupPerceptions = [];

            // éå†ä¸‰ä¸ªç­›é€‰æ¡ä»¶çš„æ‰€æœ‰å¯èƒ½å€¼
            filterConfigs.forEach(filter => {
                // è·å–å½“å‰ç­›é€‰æ¡ä»¶çš„æ‰€æœ‰é€‰é¡¹å€¼ï¼ˆé™¤äº†"all"ï¼‰
                const select = document.getElementById(filter.selectId);
                const options = Array.from(select.options)
                    .filter(opt => opt.value !== 'all')
                    .map(opt => opt.value);
                // å¯¹æ¯ä¸ªé€‰é¡¹è®¡ç®—æ„ŸçŸ¥å‡†ç¡®åº¦
                options.forEach(optionValue => {
                    // è®¾ç½®å…¶ä»–ç­›é€‰æ¡ä»¶ä¸º"all"
                    const filteredData = allData.filter(p => {
                        // å¦‚æœfilter.keyæ˜¯æ•°å€¼ç±»å‹å­—æ®µï¼Œå°†ä¸¤è¾¹éƒ½è½¬ä¸ºå­—ç¬¦ä¸²æ¯”è¾ƒ
                        if (typeof p[filter.key] === 'number') {
                            return String(p[filter.key]) === String(optionValue);
                        }
                        // å…¶ä»–æƒ…å†µç›´æ¥æ¯”è¾ƒ
                        return p[filter.key] === optionValue;
                    });
                    // å¦‚æœè¯¥ç»„æ²¡æœ‰æ•°æ®ï¼Œåˆ™è·³è¿‡
                    if (filteredData.length === 0) {
                        return;
                    }

                    const total = filteredData.length;
                    const eCnt = filteredData.filter(p => p.ieStr === 'E').length;
                    const nCnt = filteredData.filter(p => p.nsStr === 'N').length;
                    const fCnt = filteredData.filter(p => p.ftStr === 'F').length;
                    const jCnt = filteredData.filter(p => p.jpStr === 'J').length;
                    const MBTI = MyMBTI.split('');

                    // è®¡ç®—å››ä¸ªç»´åº¦çš„æ„ŸçŸ¥ç™¾åˆ†æ¯”
                    const iePct = MBTI[0] === 'I' ? Math.round((total - eCnt) / total * 100) : Math.round(eCnt / total * 100);
                    const nsPct = MBTI[1] === 'N' ? Math.round(nCnt / total * 100) : Math.round((total - nCnt) / total * 100);
                    const ftPct = MBTI[2] === 'F' ? Math.round(fCnt / total * 100) : Math.round((total - fCnt) / total * 100);
                    const jpPct = MBTI[3] === 'J' ? Math.round(jCnt / total * 100) : Math.round((total - jCnt) / total * 100);

                    // è®¡ç®—æ„ŸçŸ¥ç»´åº¦åŒ¹é…çš„æ•°é‡
                    let correctDimensions = 0;
                    if (iePct >= 50) correctDimensions++;
                    if (nsPct >= 50) correctDimensions++;
                    if (ftPct >= 50) correctDimensions++;
                    if (jpPct >= 50) correctDimensions++;

                    // è®¡ç®—æ„ŸçŸ¥çš„å¹³å‡å‡†ç¡®åº¦
                    const avgPerception = (iePct + nsPct + ftPct + jpPct) / 4;

                    // è®¡ç®—ç»„çš„å¹³å‡å°è±¡ MBTI ç±»å‹
                    const avgImpressionType = calculateImpressionType(filteredData);

                    // æ·»åŠ åˆ°ç»„æ„ŸçŸ¥æ•°ç»„
                    groupPerceptions.push({
                        filterType: filter.key,
                        filterValue: optionValue,
                        displayName: optionValue.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
                        correctDimensions,
                        avgPerception,
                        impressionType: avgImpressionType, // æ·»åŠ å¹³å‡å°è±¡ç±»å‹
                        dimensions: [iePct, nsPct, ftPct, jpPct]
                    });
                });
            });

            // æŒ‰æ­£ç¡®ç»´åº¦æ•°é‡å’Œå¹³å‡æ„ŸçŸ¥ç™¾åˆ†æ¯”æ’åº
            groupPerceptions.sort((a, b) => {
                if (b.correctDimensions !== a.correctDimensions) {
                    return b.correctDimensions - a.correctDimensions;
                }
                return b.avgPerception - a.avgPerception;
            });

            // è·å–æœ€å‡†ç¡®çš„ä¸‰ä¸ªç¾¤ä½“å’Œæœ€ä¸å‡†ç¡®çš„ä¸‰ä¸ªç¾¤ä½“
            const mostAccurate = groupPerceptions.slice(0, 3);
            const leastAccurate = groupPerceptions.slice(-3).reverse();

            // åˆ›å»ºå¹¶æ˜¾ç¤ºå‡†ç¡®åº¦æŠ¥å‘Š
            // æ›´æ–°æˆ–åˆ›å»ºå‡†ç¡®åº¦æŠ¥å‘Šå…ƒç´ 
            const accuracyReportElem = document.getElementById('accuracy-report');

            let reportContent = `
        <div style="margin: 0 0 0 30px; padding: 15px 20px; background-color: #f8f9fa; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.0); border-left: 4px solid ; font-family: 'Poppins', Arial, sans-serif;margin-bottom : 10px">
            <h3 style="margin: 0 0 15px 0; color: #333; font-size: 14px; font-weight: 600;">Groups Most Accurately Identifying Your MBTI Type:</h3>
            <ul style="margin: 0 0 20px 0; padding-left: 25px; list-style-type: disc;font-size: 12px;">
                ${mostAccurate.map(group => {
                const dimensionColor = groupColor;
                const impressionTypeHtml = formatImpressionType(group.impressionType, MyMBTI);
                return `<li style="margin-bottom: 8px; line-height: 1.4;">
                        <span style="color: ${dimensionColor}; font-weight: 600;">${group.displayName}</span>
                        <span style="color: #555; "> - Average impression: ${impressionTypeHtml}, Average accuracy: ${group.avgPerception.toFixed(1)}%</span>
                    </li>`;
            }).join('')}
            </ul>
            
            <h3 style="margin: 0 0 15px 0; color: #333; font-size: 14px; font-weight: 600; border-top: 1px solid #e0e0e0; padding-top: 15px;">Groups Least Accurately Identifying Your MBTI Type:</h3>
            <ul style="margin: 0 0 20px 0; padding-left: 25px; list-style-type: disc;font-size: 12px;">
                ${leastAccurate.map(group => {
                const dimensionColor = '#F44336';
                const impressionTypeHtml = formatImpressionType(group.impressionType, MyMBTI);
                return `<li style="margin-bottom: 8px; line-height: 1.4;">
                        <span style="color: ${dimensionColor}; font-weight: 600;">${group.displayName}</span> - 
                        <span style="color: #555; ">Average impression: ${impressionTypeHtml}, Average accuracy: ${group.avgPerception.toFixed(1)}%</span>
                    </li>`;
            }).join('')}
            </ul>
            <p style="margin: 20px 0 0 0; font-style: italic; color: #666; font-size: 12px; text-align: left;">
                You can explore and discover more by selecting different filters below. You can only select one value for one filter at a time.
            </p>
        </div>
        `;

            // æ›´æ–°æŠ¥å‘Šå†…å®¹
            accuracyReportElem.innerHTML = reportContent;
            // æ’å…¥åˆ°é›·è¾¾å›¾ä¹‹å‰
            const radarWrapper = document.querySelector('.filter-container');
            radarWrapper.parentNode.insertBefore(accuracyReportElem, radarWrapper);

            // ä»¥ä¸‹æ˜¯åŸæ¥çš„é›·è¾¾å›¾ç»˜åˆ¶ä»£ç 
            // æ‰¾åˆ°å”¯ä¸€ä¸€ä¸ªé all ç­›é€‰
            const active = filterConfigs
                .map(c => ({ ...c, value: document.getElementById(c.selectId).value }))
                .filter(c => c.value !== 'all')[0] || null;

            // è¿‡æ»¤æ•°æ®
            let subset = allData;
            let label = 'All';
            if (active) {
                subset = allData.filter(p => p[active.key] === active.value);
                label = active.value.replace(/_/g, ' ')
                    .replace(/\b\w/g, c => c.toUpperCase());
            }

            const total = subset.length || 1;
            const eCnt = subset.filter(p => p.ieStr === 'E').length;
            const nCnt = subset.filter(p => p.nsStr === 'N').length;
            const fCnt = subset.filter(p => p.ftStr === 'F').length;
            const jCnt = subset.filter(p => p.jpStr === 'J').length;
            const MBTI = MyMBTI.split('');

            const iePct = MBTI[0] === 'I' ? Math.round((total - eCnt) / total * 100) : Math.round(eCnt / total * 100);
            const nsPct = MBTI[1] === 'N' ? Math.round(nCnt / total * 100) : Math.round((total - nCnt) / total * 100);
            const ftPct = MBTI[2] === 'F' ? Math.round(fCnt / total * 100) : Math.round((total - fCnt) / total * 100);
            const jpPct = MBTI[3] === 'J' ? Math.round(jCnt / total * 100) : Math.round((total - jCnt) / total * 100);

            const key = active ? active.key : 'all';
            const borderColor = groupColor;
            const backgroundColor = borderColor + 66; // åŠ ä¸Š 20% é€æ˜åº¦

            const dataset = {
                label: "% of matching perceptions: ",
                data: [iePct, nsPct, ftPct, jpPct],
                borderColor,
                backgroundColor,
                fill: true,
                borderWidth: 2
            };

            const ctx = document.getElementById('combinedRadar').getContext('2d');
            if (combinedChart) combinedChart.destroy();
            combinedChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: MBTI,
                    datasets: [dataset]
                },
                options: {
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { stepSize: 20 }
                        }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' }
                    },
                    elements: {
                        line: { tension: 0.3 }
                    }
                }
            });
        }

        // è®¡ç®—ç¾¤ä½“çš„å¹³å‡å°è±¡ MBTI ç±»å‹
        function calculateImpressionType(data) {
            if (!data || data.length === 0) return 'XXXX'; // æ²¡æœ‰æ•°æ®æ—¶è¿”å›å ä½ç¬¦

            // ç»Ÿè®¡ I/E ç»´åº¦
            const eCnt = data.filter(p => p.ieStr === 'E').length;
            const iCnt = data.length - eCnt;
            const ieDimension = eCnt > iCnt ? 'E' : 'I';

            // ç»Ÿè®¡ N/S ç»´åº¦
            const nCnt = data.filter(p => p.nsStr === 'N').length;
            const sCnt = data.length - nCnt;
            const nsDimension = nCnt > sCnt ? 'N' : 'S';

            // ç»Ÿè®¡ F/T ç»´åº¦
            const fCnt = data.filter(p => p.ftStr === 'F').length;
            const tCnt = data.length - fCnt;
            const ftDimension = fCnt > tCnt ? 'F' : 'T';

            // ç»Ÿè®¡ J/P ç»´åº¦
            const jCnt = data.filter(p => p.jpStr === 'J').length;
            const pCnt = data.length - jCnt;
            const jpDimension = jCnt > pCnt ? 'J' : 'P';

            // ç»„åˆå½¢æˆå®Œæ•´çš„ MBTI ç±»å‹
            return ieDimension + nsDimension + ftDimension + jpDimension;
        }

        // æ ¼å¼åŒ–å°è±¡ç±»å‹ï¼Œä½¿å¾—ä¸ MyMBTI ä¸€è‡´çš„ç»´åº¦æ˜¾ç¤ºä¸ºç»¿è‰²ï¼Œä¸ä¸€è‡´çš„æ˜¾ç¤ºä¸ºçº¢è‰²
        function formatImpressionType(impressionType, myMBTI) {
            if (!impressionType || impressionType === 'XXXX') return 'Unknown';

            const impressionChars = impressionType.split('');
            const myMBTIChars = myMBTI.split('');

            let formattedType = '';

            for (let i = 0; i < 4; i++) {
                const color = impressionChars[i] === myMBTIChars[i] ? groupColor : '#F44336';
                formattedType += `<span style="color: ${color}; font-weight: 600;">${impressionChars[i]}</span>`;
            }

            return formattedType;
        }


        function updateSummary(totalCount, mistypeCount, mostCommonMistype,
            iPercent, ePercent, nPercent, sPercent,
            fPercent, tPercent, jPercent, pPercent, MyMBTI, mbtiCounts) {


            const summaryElem = document.querySelector(".summary-title");

            // if (mistypeCount === 0) {
            //     summaryElem.innerHTML = `<span class="mbti-highlight" style=" color: #4CAF50;">Everyone</span> perceived you as your type.`;
            // } else {
            //     summaryElem.innerHTML =
            //         `<span class="mbti-highlight" style=" color: #F44336;">${mistypeCount}</span> out of <span class="mbti-highlight" style=" color: #F44336;">${totalCount}</span> people perceive you 
            //        <span class="mbti-highlight" style=" color: #F44336;">different types</span>, 
            //         the most common mistypes are <span class="mbti-highlight"  style=" color: #F44336;">${mostCommonMistype}. </span>
            //         <span> </span>
            //         Refer more The â˜…â˜† 

            //         `;
            // }
            if (mistypeCount === 0) {
                summaryElem.innerHTML = `<span class="mbti-highlight" style="color: #4CAF50;">Everyone</span> perceived you as your type.`;
            } else {
                // ç¡®å®šç”¨æˆ·çš„MBTIç±»å‹å±äºå“ªä¸ª

                // è®¡ç®—å„ä¸ªç±»å‹ç»„çš„è®¤çŸ¥ç™¾åˆ†æ¯”
                const groupPerceptions = {
                    "Analyst": 0,
                    "Diplomat": 0,
                    "Sentinel": 0,
                    "Explorer": 0
                };

                // å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªmbtiCountså¯¹è±¡åŒ…å«äº†æ‰€æœ‰ç±»å‹çš„è®¡æ•°
                let total = 0;
                for (const type in mbtiCounts) {

                    total += mbtiCounts[type] || 0;

                    if (["INTJ", "INTP", "ENTJ", "ENTP"].includes(type)) {
                        groupPerceptions["Analyst"] += mbtiCounts[type] || 0;
                    } else if (["INFJ", "INFP", "ENFJ", "ENFP"].includes(type)) {
                        groupPerceptions["Diplomat"] += mbtiCounts[type] || 0;
                    } else if (["ISTJ", "ISFJ", "ESTJ", "ESFJ"].includes(type)) {
                        groupPerceptions["Sentinel"] += mbtiCounts[type] || 0;
                    } else if (["ISTP", "ISFP", "ESTP", "ESFP"].includes(type)) {
                        groupPerceptions["Explorer"] += mbtiCounts[type] || 0;
                    }
                }

                // è®¡ç®—å„ç»„ç™¾åˆ†æ¯”
                const percentages = {};
                for (const group in groupPerceptions) {
                    percentages[group] = total > 0 ? Math.round((groupPerceptions[group] / total) * 100) : 0;
                }
                console.log(percentages);
                // æ‰¾å‡ºé™¤äº†ç”¨æˆ·è‡ªå·±ç»„å¤–è®¤ä¸ºæœ€å¤šçš„ç»„
                let otherGroups = Object.keys(percentages).filter(g => g !== userTypeGroup);
                let topMisperceiveGroup = otherGroups.reduce((a, b) => percentages[a] > percentages[b] ? a : b);


                if (topMisperceiveGroup === "Analyst") topMisperceiveColor = "#9B6784";
                else if (topMisperceiveGroup === "Diplomat") topMisperceiveColor = "#61AD89";
                else if (topMisperceiveGroup === "Sentinel") topMisperceiveColor = "#80CCDF";
                else if (topMisperceiveGroup === "Explorer") topMisperceiveColor = "#E1C134";

                //         summaryElem.innerHTML =
                //             `<span class="mbti-highlight" style=" font:bold">${mistypeCount}</span> out of <span class="mbti-highlight" style=" style=" font:bold";">${totalCount}</span> people perceive you 
                // <span class="mbti-highlight" style=" font:bold">different types</span>, 
                // the most common mistypes are <span class="mbti-highlight" style=" font:bold">${mostCommonMistype}. </span>
                // Most people who don't see you as your true type perceive you as a <span class="mbti-highlight" style="color: ${topMisperceiveColor};">${topMisperceiveGroup}</span> type.
                //  </p>
                // <p style="margin: 5px 0 0 0; font-style: italic; color: #666; font-size: 12px; text-align: center;"># of â˜… indicates how many dimensions match your MBTI.</p>`;
                summaryElem.innerHTML =
                    `<span class="mbti-highlight" style="font-weight: bold;">${mistypeCount}</span> out of 
     <span class="mbti-highlight" style="font-weight: bold;">${totalCount}</span> people perceive you  
     <span class="mbti-highlight" style="font-weight: bold;">different types</span>. 
     The most common guesses are <span class="mbti-highlight" style="font-weight: bold;">${mostCommonMistype}</span>. 
     
     
     `;

                //  People who donâ€™t see your true type mostly think you are a 
                //  <span class="mbti-highlight" style="color: ${topMisperceiveColor}; font-weight: bold;">${topMisperceiveGroup}</span> type.
                //  <p style="margin: 5px 0 0 0; font-style: italic; color: #666; font-size: 12px; text-align: center;">
                //     â˜… shows how many dimensions match your real MBTI.
                //  </p>
            }

            const summaryList = document.querySelector(".summary-list");
            summaryList.innerHTML = `<li><canvas id="summaryChart" width="400" height="400"></canvas></li>`;
            // Determine the four core percentages based on your MBTI
            const dataPoints = [
                MyMBTI[0] === 'I' ? iPercent : ePercent,
                MyMBTI[1] === 'N' ? nPercent : sPercent,
                MyMBTI[2] === 'F' ? fPercent : tPercent,
                MyMBTI[3] === 'J' ? jPercent : pPercent
            ];
            // æ›´æ–°å›¾è¡¨æ ‡é¢˜ï¼Œæ·»åŠ ç»´åº¦ç™¾åˆ†æ¯”è§£é‡Šï¼Œä½¿ç”¨é¡¹ç›®ç¬¦å·åˆ—è¡¨å¹¶é«˜äº®ç™¾åˆ†æ¯”
            const perceptionDimensionElem = document.querySelector(".chart-title");

            // è·å–ç”¨æˆ·çš„MBTIç±»å‹çš„å„ä¸ªç»´åº¦
            const iDim = MyMBTI[0];
            const sDim = MyMBTI[1];
            const tDim = MyMBTI[2];
            const jDim = MyMBTI[3];
            const getOpposite = (letter) => {
                const opposites = {
                    'I': 'E', 'E': 'I',
                    'N': 'S', 'S': 'N',
                    'F': 'T', 'T': 'F',
                    'J': 'P', 'P': 'J'
                };
                return opposites[letter] || letter;
            };
            // ç¡®å®šæ¯å¯¹ç»´åº¦ä¸­ç™¾åˆ†æ¯”è¾ƒé«˜çš„ä¸€ä¸ª
            const firstLetter = dataPoints[0] >= 50 ? MyMBTI[0] : getOpposite(MyMBTI[0]);
            const secondLetter = dataPoints[1] >= 50 ? MyMBTI[1] : getOpposite(MyMBTI[1]);
            const thirdLetter = dataPoints[2] >= 50 ? MyMBTI[2] : getOpposite(MyMBTI[2]);
            const fourthLetter = dataPoints[3] >= 50 ? MyMBTI[3] : getOpposite(MyMBTI[3]);
            // ç»„åˆæˆå®Œæ•´çš„MBTIç±»å‹
            const perceivedType = firstLetter + secondLetter + thirdLetter + fourthLetter;

            // åˆ›å»ºå¸¦é¡¹ç›®ç¬¦å·å’Œé«˜äº®çš„ç™¾åˆ†æ¯”æ–‡å­—è¯´æ˜
            perceptionDimensionElem.innerHTML = `
  <div style=" text-align: left;">
    <div padding: 0; margin: 0;>
    People's average impression of you is <span class="mbti-highlight" style="color: ${perceivedType === MyMBTI ? groupColor : find_color(perceivedType)}">${perceivedType}.</span>
    </div>
    <ul style=" padding-left: 20px; margin: 0;">
    <li><span class="mbti-highlight" style="color: ${groupColor};">${dataPoints[0]}%</span> correctly perceive your ${MyMBTI[0]}</li>
    <li><span class="mbti-highlight" style="color: ${groupColor};">${dataPoints[1]}%</span> correctly perceive your ${MyMBTI[1]}</li>
    <li><span class="mbti-highlight" style="color: ${groupColor};">${dataPoints[2]}%</span> correctly perceive your ${MyMBTI[2]}</li>
    <li><span class="mbti-highlight" style="color: ${groupColor};">${dataPoints[3]}%</span> correctly perceive your ${MyMBTI[3]}</li>
</ul>
  </div>
`;
            const ctx = document.getElementById('summaryChart').getContext('2d');
            // Destroy existing chart if present
            if (window.summaryRadar) window.summaryRadar.destroy();

            // Create the radar chart
            window.summaryRadar = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: [MyMBTI[0], MyMBTI[1], MyMBTI[2], MyMBTI[3]],
                    datasets: [{
                        label: '% of matching perceptions: ',
                        data: dataPoints,
                        backgroundColor: groupColor + 66,
                        borderColor: groupColor,
                        pointBackgroundColor: groupColor,
                        pointBorderColor: '#fff',
                        pointRadius: 3,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { stepSize: 20, font: { size: 10 } },
                            grid: { color: '#e0e0e0' },
                            angleLines: { color: '#e0e0e0' },
                            pointLabels: {
                                font: { family: 'Poppins', size: 20 },
                                color: groupColor
                            }
                        }
                    },
                    plugins: { legend: { display: false } },
                    elements: { line: { tension: 0.3 } },
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }

        function updateFilterSections() {
            console.log('âš™ï¸ updateFilterSections() called');
            const filters = [
                { key: 'relationshipType', sectionId: 'relationshipTypeSection' },
                { key: 'sinceWhen', sectionId: 'sinceWhenSection' },
                // { key: 'familiarity', sectionId: 'intimacyGraphSection' },
                { key: 'interactionPlace', sectionId: 'interactionPlaceSection' }
            ];

            filters.forEach(({ key, sectionId }) => {
                const displayName = [];
                const ieUserPct = [];
                const nsUserPct = [];
                const ftUserPct = [];
                const jpUserPct = [];
                const ul = document.getElementById(sectionId);
                // æŒ‰ filter åˆ†ç»„
                const groups = allData.reduce((acc, p) => {
                    const v = p[key] || 'Unknown';
                    (acc[v] = acc[v] || []).push(p);
                    return acc;
                }, {});
                Object.entries(groups).forEach(([group, list]) => {
                    if (group === 'Unknown' && list.length < 3) return;
                    const total = list.length;
                    // è®¡ç®—æ¯ä¾§äººæ•°
                    const eCnt = list.filter(p => p.ieStr === 'E').length;
                    const iCnt = total - eCnt;
                    const nCnt = list.filter(p => p.nsStr === 'N').length;
                    const sCnt = total - nCnt;
                    const fCnt = list.filter(p => p.ftStr === 'F').length;
                    const tCnt = total - fCnt;
                    const jCnt = list.filter(p => p.jpStr === 'J').length;
                    const pCnt = total - jCnt;

                    // åŸºäºä½ çš„ MBTI ä¾§è®¡ç®—ç™¾åˆ†æ¯”
                    ieUserPct.push(MyMBTI[0] === 'I' ? Math.round(iCnt / total * 100) : Math.round(eCnt / total * 100));
                    nsUserPct.push(MyMBTI[1] === 'N' ? Math.round(nCnt / total * 100) : Math.round(sCnt / total * 100));
                    ftUserPct.push(MyMBTI[2] === 'F' ? Math.round(fCnt / total * 100) : Math.round(tCnt / total * 100));
                    jpUserPct.push(MyMBTI[3] === 'J' ? Math.round(jCnt / total * 100) : Math.round(pCnt / total * 100));

                    displayName.push(group.replace(/_/g, ' ')
                        .replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()));
                });
                console.log(displayName);
                // å®šä¹‰ä¸€ä¸ªè°ƒè‰²æ¿ï¼ˆå¯ä»¥æ ¹æ® displayName å¢åŠ é¢œè‰²ï¼‰



                // æ‰¾åˆ°å¯¹åº” section ä¸‹çš„ canvasï¼Œå‡è®¾ä½ åœ¨ HTML é‡Œç»™æ¯ä¸ª section åŠ äº†
                // <canvas id="${sectionId}Radar"></canvas>
                const canvas = document.getElementById(sectionId + 'Radar');
                const ctx = canvas.getContext('2d');

                // æ„å»º datasets
                const datasets = displayName.map((name, i) => ({
                    label: '% of matching perceptions: ',
                    data: [
                        ieUserPct[i],
                        nsUserPct[i],
                        ftUserPct[i],
                        jpUserPct[i]
                    ],
                    borderColor: radarColors[i],

                    borderWidth: 2,
                    fill: true
                }));

                // å¦‚æœå·²ç»æœ‰æ—§å›¾è¡¨ï¼ŒæŠŠå®ƒæ‘§æ¯
                if (window[sectionId + 'Chart']) {
                    window[sectionId + 'Chart'].destroy();
                }

                // æ–°å»ºä¸€ä¸ª Radar
                window[sectionId + 'Chart'] = new Chart(ctx, {
                    type: 'radar',
                    data: {
                        labels: MyMBTI.split(''),   // ['I','N','F','J']
                        datasets
                    },
                    options: {
                        scales: {
                            r: {
                                beginAtZero: true,
                                max: 100,
                                ticks: { stepSize: 20 }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        elements: {
                            line: { tension: 0.3 }
                        }
                    }
                });

            });

        }

        // Call this function after the DOM has loaded


    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f5f8fb;
            color: #333;
            margin: 0;
            padding: 30px;

        }

        .main-container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        .header-section {
            text-align: center;
            padding: 15px;
            border-bottom: 1px solid #eaeaea;
        }

        .header-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        #mbti-title {
            font-size: 18px;

        }

        .summary-section {
            text-align: left;
        }

        .summary-title {
            font-size: 14px;
            margin-bottom: 0px;
        }

        .summary-list {
            list-style-type: none;
            padding-left: 0;
        }

        /* Slider styles for trait visualization */
        .trait-slider {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .trait-label {
            font-weight: bold;
            width: 20px;
            text-align: center;
            color: #203270;
        }

        .slider-container {
            flex-grow: 1;
        }

        .slider-bar {
            height: 12px;
            background-color: #e0e0e0;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
        }

        .slider-fill {
            height: 100%;
            background-color: #203270;
            border-radius: 6px 0 0 6px;
        }

        .slider-percentages {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 2px;
            color: #666;
        }


        .visualization-section {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            /* çˆ¶å®¹å™¨é¡¶éƒ¨å¯¹é½ */
            gap: 20px;
        }

        .chart-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* å­å…ƒç´ å·¦å¯¹é½ï¼Œæ ‡é¢˜å’Œæ–‡å­—é å·¦ */
            justify-content: flex-start;
            /* å­å…ƒç´ ä»é¡¶éƒ¨å¼€å§‹æ’åˆ— */
            width: 48%;
            /* å¦‚æœä¸éœ€è¦å›ºå®šé«˜åº¦ï¼Œæœ€å¥½åˆ æ‰ä¸‹é¢è¿™ä¸€è¡Œï¼Œè®©å†…å®¹å†³å®šé«˜åº¦ */

            padding: 10px;
            box-sizing: border-box;
        }

        .chart-container .mbti-visualization {
            margin-top: 20%;
        }

        .relationship-section {
            text-align: left;
            padding: 30px 20px;
            border-top: 1px solid #eaeaea;
            background-color: #fafafa;
            margin-bottom: 20px;
        }

        .relationship-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #333;
            border-left: 4px solid #4a6fa5;
            padding-left: 12px;
        }

        .section-description {
            margin-bottom: 20px;
            color: #555;
            font-size: 14px;
            line-height: 1.5;
        }

        .section-description ul {
            padding-left: 20px;
        }

        /* Card grid layout */
        .relationship-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        /* Card styling */
        .relationship-list li {
            background: #fff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: transform .2s, box-shadow .2s;
            display: flex;
            flex-direction: column;
        }

        .relationship-list li:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
        }

        /* Group name styling */
        .group-name {
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
            text-align: center;
        }

        /* Trait bars container */
        .trait-bars {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
        }

        /* Individual trait bar */
        .trait-bar {
            width: 100%;
        }

        .trait-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 13px;
            font-weight: 500;
        }

        .trait-name {
            color: #555;
        }

        .trait-percentage {
            color: #333;
            font-weight: 600;
        }

        /* Progress bar container */
        .trait-progress {
            height: 12px;
            width: 100%;
            background-color: #f0f0f0;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        /* Progress bar fill styles for each trait */
        .trait-fill {
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            border-radius: 6px;
            transition: width 0.5s ease;
        }

        /* Distinct colors for each personality dimension */

        /* Legend at the top */
        .personality-legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 24px;
            padding: 16px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-text {
            font-size: 14px;
            color: #555;
        }

        .radar-chart-wrapper {
            width: 400px;
            height: 400px;
            margin: 0 auto;
            /* å·¦å³è‡ªåŠ¨å¤–è¾¹è·ï¼Œæ°´å¹³å±…ä¸­ */
        }

        /* 2. CSS */
        .filter-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;

            margin-bottom: 1rem;
        }

        .filter-item {
            position: relative;
            display: flex;
            flex-direction: column;
            font-size: 0.9rem;
            margin: 0 auto;
        }

        .filter-item label {
            margin-bottom: 0.25rem;
            color: #444;
            font-weight: 500;
        }

        /* â†“â†“â†“ é€æ˜ç®€çº¦ä¸‹æ‹‰æ¡†æ ·å¼ â†“â†“â†“ */
        .filter-item select {
            /* å»æ‰ç³»ç»Ÿé»˜è®¤æ ·å¼ */
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;

            /* åŠé€æ˜ç™½èƒŒæ™¯ + è½»è–„è¾¹æ¡† */
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 4px;

            /* å†…è¾¹è·å‡å°ï¼Œæ›´ç²¾è‡´ */
            padding: 0.4rem 0.8rem;
            color: #333;
            font-size: 0.9rem;

            /* è¿‡æ¸¡æ•ˆæœ */
            transition:
                background 0.2s ease,
                border-color 0.2s ease,
                box-shadow 0.2s ease;
            cursor: pointer;
        }

        .filter-item select:hover {
            /* èƒŒæ™¯åŠ ä¸€ç‚¹ä¸é€æ˜åº¦ */
            background: rgba(255, 255, 255, 0.8);
        }

        .filter-item select:focus {
            outline: none;
            /* æ›´æ˜æ˜¾çš„è¾¹æ¡† + å¾®å¼±é˜´å½± */
            border-color: rgba(0, 0, 0, 0.3);
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
            background: rgba(255, 255, 255, 0.9);
        }

        /* è‡ªå®šä¹‰ç®­å¤´ï¼Œé¢œè‰²æŸ”å’Œ */
        .filter-item::after {
            content: 'â–¾';
            position: absolute;
            top: 50%;
            right: 0.8rem;
            transform: translateY(-50%);
            pointer-events: none;
            color: rgba(0, 0, 0, 0.4);
        }

        /* ä¸‹æ‹‰é€‰é¡¹é¢œè‰²æ¢å¤åŸç”Ÿæ¸…æ™°é£æ ¼ */
        .filter-item select option {
            background: #fff;
            color: #333;
        }

        .radar-chart-wrapper canvas {

            width: 100% !important;
            height: 100% !important;
        }


        .chart-description,
        .section-description {
            font-size: 13px;
            color: #555;
            margin: 8px 0 12px;
        }

        .chart-description ul,
        .section-description ul {
            padding-left: 18px;
            margin: 0;
        }

        .chart-description li,
        .section-description li {
            margin-bottom: 4px;
        }

        .mbti-highlight {
            font-weight: bold;

        }

        .chart-title {
            text-align: center;

            font-size: 14px;

        }

        .mbti-visualization {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            max-width: 350px;
            margin-left: auto;
            margin-right: auto;
        }

        .mbti-type {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            border: 2px solid #8FB9D1;
            font-weight: bold;
            position: relative;
            font-size: 14px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .mbti-type.your-type {
            border: 3px solid #203270;
            background-color: #e8f4ff;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(32, 50, 112, 0.2);
        }

        #mbtiSankeyChart {
            width: 500px;
            height: 350px;
            margin: 0 auto;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s;
        }

        .node:hover {
            stroke: #59aaf0;
            stroke-width: 1px;
        }

        .active-node {
            stroke: #59aaf0;
            stroke-width: 1px;
        }

        .node-label {
            pointer-events: none;
            font-weight: 500;
        }

        .percentage-label {
            pointer-events: none;
            font-weight: 500;
            fill: #333;
        }

        .mbti-star {
            pointer-events: none;
        }

        .hidden {
            display: none;
        }

        .visible {
            display: block;
        }

        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            max-width: 300px;
            font-size: 12px;
        }

        .connection-line {
            transition: opacity 0.3s;
        }

        .diff-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 1px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 10px;
            color: #555;
        }

        .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 6px;
            border-radius: 2px;
            border: 1px solid #ccc;
        }

        .diff-indicator {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #555;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 10px;
            line-height: 1;
        }

        .mbti-type:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
            z-index: 10;
        }

        .mbti-type.your-type:hover {
            transform: scale(1.1);
        }

        .tab-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }

        .tab {
            padding: 5px 15px;
            border: 1px solid #ddd;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab.active {
            background-color: #203270;
            color: white;
            border-color: #203270;
        }

        /* Add space between different sections */
        section {
            margin-bottom: 10px;
        }
    </style>
</head>

<body>

    <div class="main-container">
        <!-- Header Section -->
        <section class="header-section">
            <div class="header-title">MBTI Perception Report</div>
            <div id="mbti-title">Your MBTI Type: Loading...</div>
        </section>

        <!-- Summary Section -->


        <!-- Visualization Section -->
        <section class="visualization-section">
            <div class="chart-container">

                <section class="summary-section">
                    <div class="summary-title">Loading data...</div>
                </section>
                <div class="radar-chart-wrapper">
                    <div id="mbtiSankeyChart"></div>
                </div>
            </div>
            <div class="chart-container">
                <div class="chart-title">Overall Trait Perception</div>
                <ul class="summary-list">
                    <li>Loading...</li>
                </ul>
            </div>
        </section>
        <div id="accuracy-report"></div>
        <!-- 1. HTML -->
        <div class="filter-container">
            <div class="filter-item">
                <label for="filterRelType">Relationship Type:</label>
                <select id="filterRelType">
                    <option value="all">All</option>
                    <!-- æ ¹æ®ä½ çš„æ•°æ®åŠ¨æ€æ’å…¥<option value="Family">Family</option>ç­‰ -->
                </select>
            </div>
            <div class="filter-item">
                <label for="filterSinceWhen">Know Time:</label>
                <select id="filterSinceWhen">
                    <option value="all">All</option>
                    <!-- åŠ¨æ€æ’å…¥ -->
                </select>
            </div>
            <!-- <div class="filter-item">
                <label for="filterFamiliarity">Familiarity:</label>
                <select id="filterFamiliarity">
                    <option value="all">All</option>
                </select>
            </div> -->
            <div class="filter-item">
                <label for="filterInteraction">Interaction Place:</label>
                <select id="filterInteraction">
                    <option value="all">All</option>
                    <!-- åŠ¨æ€æ’å…¥ -->
                </select>
            </div>
        </div>

        <div class="radar-chart-wrapper">
            <canvas id="combinedRadar"></canvas>
        </div>


    </div>
    </div>
</body>

</html>