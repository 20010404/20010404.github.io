<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBTI Filter View</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f5f8fb;
            color: #333;
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .main-wrapper {
            display: flex;
            width: 80%;
            flex-direction: column;
            align-items: center;
        }

        .dimension-tabs {
            margin: 20px 0;
        }

        .tab {
            padding: 10px 15px;
            margin: 0 5px;
            border: none;
            border-radius: 20px;
            background: linear-gradient(135deg, #5B83B8, #FFD4EA);
            color: white;
            cursor: pointer;
            font-weight: bold;
        }

        .tab.active {
            box-shadow: 0 0 10px #e995b8;
        }

        .chart-container {
            width: 70%;
            margin: 0 auto;
            background: linear-gradient(to bottom right, #ffffff, #f0f4f9);
            border-radius: 16px;
            padding: 25px 30px;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
        }

        #legend-container {
            text-align: left;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .tooltip-dot {
            position: relative;
        }

        .tooltip-dot:hover::after {
            content: attr(data-tooltip);
            width: 200px;
            white-space: pre-line;
            position: absolute;
            top: -50px;
            left: 0;
            background: white;
            border: 1px solid #ccc;
            padding: 6px 10px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
            font-size: 13px;
            color: #333;
            z-index: 10;
        }
    </style>
</head>

<body>
    <div class="main-wrapper">
        <h2 id="mbti-title">MBTI Filter View</h2>

        <div class="dimension-tabs">
            <button class="tab active" data-dimension="IE">I/E</button>
            <button class="tab" data-dimension="NS">N/S</button>
            <button class="tab" data-dimension="FT">F/T</button>
            <button class="tab" data-dimension="JP">J/P</button>
            <button class="tab" data-dimension="ALL">ALL</button>
        </div>

        <div class="chart-container">
            <div id="legend-container"></div>
            <div id="counts-container"></div>
            <div id="mbtiFilterTableContainer"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
        import { getDatabase, ref, query, orderByChild, equalTo, get } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCvc9C5PuDqrI26jrmsg5b1PVOW6_k43W4",
            authDomain: "mbti-kale.firebaseapp.com",
            databaseURL: "https://mbti-kale-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "mbti-kale",
            storageBucket: "mbti-kale.firebasestorage.app",
            messagingSenderId: "756176954275",
            appId: "1:756176954275:web:7581e5e485e426b33ff016",
            measurementId: "G-B6F0F4JZ7E"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const urlParams = new URLSearchParams(window.location.search);
        const username = urlParams.get("name");
        const filterType = urlParams.get("filter");
        const MyMBTI = urlParams.get("mbti");

        let allData = [];

        const traitColors = {
            IE: { I: '#01847F', E: '#F9D2E4' },
            NS: { N: '#002FA7', S: '#FFE76F' },
            FT: { F: '#FF770F', T: '#000026' },
            JP: { J: '#6B946A', P: '#DDD23B' }
        };

        const coloredMBTI = MyMBTI.split("").map(char => `<span style="color:${getColorForLetter(char)}">${char}</span>`).join("");
        document.getElementById("mbti-title").innerHTML = `<span style="color:#555">Your Type: </span>${coloredMBTI}`;

        document.querySelectorAll(".tab").forEach(btn => {
            btn.addEventListener("click", () => {
                document.querySelectorAll(".tab").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
                const dimension = btn.dataset.dimension;
                drawChart(dimension);
            });
        });

        function getColorForLetter(letter) {
            return traitColors.IE[letter] || traitColors.NS[letter] || traitColors.FT[letter] || traitColors.JP[letter] || '#999';
        }

        async function fetchData() {
            const dbRef = ref(database, "responses");
            const q = query(dbRef, orderByChild("username"), equalTo(username));
            const snapshot = await get(q);
            allData = [];

            if (!snapshot.exists()) return;
            snapshot.forEach(child => {
                const d = child.val();
                if (d.ie && d.ns && d.ft && d.jp) {
                    allData.push({
                        email: d.email,
                        ie: d.ie,
                        ns: d.ns,
                        ft: d.ft,
                        jp: d.jp,
                        familiarity2: parseInt(d.intimacyGraphReverse) || 1,
                        intimacyGraph: parseInt(d.intimacyGraph) || 1,
                        relationshipType: d.relationshipType,
                        sinceWhen: d.sinceWhen,
                        interactionPlace: d.interactionPlace,
                        filterValue: d[filterType] || " "
                    });
                }
            });
            drawChart("IE");
        }

        function drawChart(dimension) {
            const container = document.getElementById("mbtiFilterTableContainer");
            container.innerHTML = "";

            if (dimension === "ALL") {
                const myMBTI = MyMBTI.toUpperCase();
                const centerX = 300;
                const centerY = 300;

                const colorMatch = "#333";  // 蓝绿色匹配色
                const colorDiff = "#ff6b81";   // 不一致的维度色
                const outerColors = ["#a6dff2", "#3eb5e1", "#1a79db", "#0e4e90", "#05465e"]; // 多种 pastel 外圈色

                const typeMap = {};
                allData.forEach(d => {
                    const type = `${d.ie[0]}${d.ns[0]}${d.ft[0]}${d.jp[0]}`.toUpperCase();
                    if (!typeMap[type]) {
                        typeMap[type] = { count: 0, emails: [], diff: 0, names: [] };
                    }
                    typeMap[type].count++;
                    typeMap[type].emails.push(d.email);
                    if (filterType == "table") {
                        typeMap[type].names.push(`Name : ${d.email}\n Your Familiarity to him/her : ${d.familiarity2}\n His/her familariyty to you: ${d.intimacyGraph}\n relationship type: ${d.relationshipType}\n Known years: ${d.sinceWhen}\n Interaction place: ${d.interactionPlace}\n`);
                    }
                    else if (filterType == "intimacyGraph") {
                        typeMap[type].names.push(`Name : ${d.email}\n Your Familiarity to him/her: ${d.familiarity2}\n His/her familariyty to you: ${d[filterType]}`);
                    }
                    else {
                        typeMap[type].names.push(`Name : ${d.email}\n Your Familiarity to him/her: ${d.familiarity2}\n ${filterType}: ${d[filterType]}`);
                    }

                    let diff = 0;
                    for (let i = 0; i < 4; i++) {
                        if (type[i] !== myMBTI[i]) diff++;
                    }
                    typeMap[type].diff = diff;
                });

                const canvas = document.createElement("canvas");
                canvas.width = 600;
                canvas.height = 600;
                canvas.style.transition = "opacity 0.6s ease-in-out";
                canvas.style.opacity = 0;
                container.appendChild(canvas);
                const ctx = canvas.getContext("2d");

                const sortedEntries = Object.entries(typeMap).sort((a, b) => a[1].diff - b[1].diff);
                const points = sortedEntries.map(([type, data], index) => {
                    const angle = (index / sortedEntries.length) * 2 * Math.PI;
                    const distance = 80 + data.diff * 40;
                    return {
                        x: centerX + Math.cos(angle) * distance,
                        y: centerY + Math.sin(angle) * distance,
                        type,
                        emails: data.names.join("\n"),
                        diff: data.diff,
                        colorIndex: data.diff % outerColors.length
                    };
                });

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                let i = 0;
                function drawNext() {
                    if (i >= points.length) return;
                    const p = points[i];

                    // 背景圈
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 38, 0, 2 * Math.PI);
                    ctx.fillStyle = "#ffffff";
                    ctx.fill();
                    ctx.strokeStyle = outerColors[p.colorIndex];
                    ctx.lineWidth = 4;
                    ctx.shadowColor = "rgba(0, 0, 0, 0.15)";
                    ctx.shadowBlur = 10;
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // 字母着色
                    for (let j = 0; j < 4; j++) {
                        ctx.fillStyle = p.type[j] !== myMBTI[j] ? colorDiff : colorMatch;
                        ctx.font = "bold 15px Poppins";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(p.type[j], p.x - 18 + j * 12, p.y);
                    }

                    // diff 值
                    ctx.fillStyle = "#888";
                    ctx.font = "12px Poppins";
                    ctx.fillText(`${p.diff} diff`, p.x, p.y + 26);

                    i++;
                    setTimeout(drawNext, 200);
                }

                drawNext();
                setTimeout(() => {
                    canvas.style.opacity = 1;
                }, 200);

                // 中心圆圈
                ctx.beginPath();
                ctx.arc(centerX, centerY, 50, 0, 2 * Math.PI);
                ctx.fillStyle = "#fff";
                ctx.fill();
                ctx.strokeStyle = "#a6dff2";
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fillStyle = "#a6dff2";
                ctx.font = "bold 25px Poppins";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(myMBTI, centerX, centerY);

                // Tooltip
                const tooltip = document.createElement("div");
                Object.assign(tooltip.style, {
                    position: "absolute",
                    padding: "10px 14px",
                    background: "rgba(255,255,255,0.95)",
                    border: "1px solid #ccc",
                    borderRadius: "8px",
                    boxShadow: "0 4px 10px rgba(0,0,0,0.15)",
                    fontSize: "13px",
                    fontFamily: "Poppins, sans-serif",
                    color: "#222",
                    whiteSpace: "pre-line",
                    display: "none",
                    pointerEvents: "none",
                    zIndex: 1000
                });
                document.body.appendChild(tooltip);

                canvas.addEventListener("mousemove", e => {
                    const rect = canvas.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;

                    let found = false;
                    for (const pt of points) {
                        if (Math.hypot(mx - pt.x, my - pt.y) <= 38) {
                            tooltip.textContent = pt.emails;
                            tooltip.style.left = `${e.pageX + 12}px`;
                            tooltip.style.top = `${e.pageY + 12}px`;
                            tooltip.style.display = "block";
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        tooltip.style.display = "none";
                    }
                });

                canvas.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                });

                return;
            }


            const values = [...new Set(allData.map(d => d.filterValue))];
            const left = dimension[0];
            const right = dimension[1];
            const dimKey = dimension.toLowerCase();

            const table = document.createElement("table");
            table.style.width = "100%";
            table.style.borderCollapse = "collapse";
            table.style.marginTop = "20px";
            table.style.fontFamily = "Poppins, sans-serif";

            const headerRow = document.createElement("tr");
            headerRow.innerHTML = `<th></th>` + values.map(v => `<th>${v}</th>`).join("");
            table.appendChild(headerRow);

            [left, right].forEach(side => {
                const row = document.createElement("tr");
                const rowHeader = document.createElement("td");
                rowHeader.textContent = side;
                rowHeader.style.fontWeight = "bold";
                row.appendChild(rowHeader);

                values.forEach(val => {
                    const cell = document.createElement("td");
                    cell.style.border = "1px solid #ccc";
                    cell.style.padding = "10px";
                    cell.style.minHeight = "50px";

                    const dots = allData.filter(d => d[dimKey].toUpperCase() === side && d.filterValue === val);
                    dots.forEach(dot => {
                        const div = document.createElement("div");
                        div.className = "tooltip-dot";
                        div.setAttribute("data-tooltip", `Name: ${dot.email}
Your Familiarity: ${dot.familiarity2}`);
                        div.style.width = "10px";
                        div.style.height = "10px";
                        div.style.borderRadius = "50%";
                        div.style.margin = "2px";
                        div.style.backgroundColor = traitColors[dimension][side] || "gray";
                        div.style.display = "inline-block";
                        div.style.cursor = "pointer";
                        cell.appendChild(div);
                    });

                    row.appendChild(cell);
                });

                table.appendChild(row);
            });

            container.appendChild(table);
        }

        fetchData();
    </script>
</body>

</html>