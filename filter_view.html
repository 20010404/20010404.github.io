<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBTI Filter View</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <script src="path/to/mbti_heatmap_radial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- 先引入 Chart.js UMD 全局版 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <!-- 再引入 DataLabels 插件的 UMD 版 -->
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
        import { getDatabase, ref, query, orderByChild, equalTo, get } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-database.js";
        Chart.register(ChartDataLabels);
        const firebaseConfig = {
            apiKey: "AIzaSyCvc9C5PuDqrI26jrmsg5b1PVOW6_k43W4",
            authDomain: "mbti-kale.firebaseapp.com",
            databaseURL: "https://mbti-kale-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "mbti-kale",
            storageBucket: "mbti-kale.firebasestorage.app",
            messagingSenderId: "756176954275",
            appId: "1:756176954275:web:7581e5e485e426b33ff016",
            measurementId: "G-B6F0F4JZ7E"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const urlParams = new URLSearchParams(window.location.search);
        const username = urlParams.get("name");
        const filterType = urlParams.get("filter") || "relationshipType";
        const MyMBTI = urlParams.get("mbti") || "ENFP";
        // 在你的脚本里（确保在 MyMBTI 已经有值后运行）：
        const legendConfig = [
            { code: 'I/E', keys: ['I', 'E'], labels: ['Introverted', 'Extroverted'], css: 'ie-color' },
            { code: 'N/S', keys: ['N', 'S'], labels: ['Intuitive', 'Sensing'], css: 'ns-color' },
            { code: 'F/T', keys: ['F', 'T'], labels: ['Feeling', 'Thinking'], css: 'ft-color' },
            { code: 'J/P', keys: ['J', 'P'], labels: ['Judging', 'Perceiving'], css: 'jp-color' }
        ];


        let allData = [];

        document.addEventListener('DOMContentLoaded', async function () {
            // Update the MBTI title with the user's MBTI type from URL
            const mbtiParts = MyMBTI.split('');
            document.getElementById("mbti-title").innerHTML = `Your MBTI Type: <span class="mbti-highlight" style=" color: #4CAF50;">${mbtiParts.join('')}</span>`;

            await fetchData();
            processData();
        });

        async function fetchData() {
            try {
                const dbRef = ref(database, "responses");
                const q = query(dbRef, orderByChild("username"), equalTo(username));
                const snapshot = await get(q);
                allData = [];

                if (!snapshot.exists()) {
                    console.log("No data found for this username");
                    document.querySelector(".summary-title").innerHTML = "No data found for this username";
                    return;
                }

                snapshot.forEach(child => {
                    const d = child.val();
                    if (d.ie && d.ns && d.ft && d.jp) {
                        // Directly create MBTI type from the string values
                        const mbtiType = d.ie + d.ns + d.ft + d.jp;

                        // Convert string values to numerical for charts
                        const ieVal = d.ie === "I" ? -1 : 1;
                        const nsVal = d.ns === "N" ? -1 : 1;
                        const ftVal = d.ft === "F" ? -1 : 1;
                        const jpVal = d.jp === "J" ? -1 : 1;

                        allData.push({
                            email: d.email,
                            ie: ieVal,
                            ns: nsVal,
                            ft: ftVal,
                            jp: jpVal,
                            ieStr: d.ie,
                            nsStr: d.ns,
                            ftStr: d.ft,
                            jpStr: d.jp,
                            mbtiType: mbtiType,
                            familiarity: parseInt(d.intimacyGraphReverse) || 1,
                            intimacy: parseInt(d.intimacyGraph) || 1,
                            relationshipType: d.relationshipType || "Unknown",
                            sinceWhen: d.sinceWhen || "Unknown",
                            interactionPlace: d.interactionPlace || "Unknown",
                        });
                        console.log("Processed data entry:", mbtiType, ieVal, nsVal, ftVal, jpVal);
                    }
                });

                console.log("Fetched data:", allData);
            } catch (error) {
                console.error("Error fetching data:", error);
                document.querySelector(".summary-title").innerHTML = "Error fetching data: " + error.message;
            }
        }

        // This function is no longer needed as we're using the string values directly
        // Keeping it here in case we need to convert numerical values to MBTI strings in the future
        function getMBTIFromTraits(ie, ns, ft, jp) {
            if (typeof ie === 'string') return ie + ns + ft + jp;

            return (ie < 0 ? "I" : "E") +
                (ns < 0 ? "N" : "S") +
                (ft < 0 ? "F" : "T") +
                (jp < 0 ? "J" : "P");
        }

        function processData() {
            if (allData.length === 0) return;

            // Calculate MBTI type distribution
            const mbtiCounts = {};
            allData.forEach(person => {
                const type = person.mbtiType;
                mbtiCounts[type] = (mbtiCounts[type] || 0) + 1;
            });

            // Calculate trait statistics
            let iCount = 0, eCount = 0, nCount = 0, sCount = 0, fCount = 0, tCount = 0, jCount = 0, pCount = 0;
            allData.forEach(person => {
                if (person.ieStr === "I") iCount++;
                if (person.ieStr === "E") eCount++;
                if (person.nsStr === "N") nCount++;
                if (person.nsStr === "S") sCount++;
                if (person.ftStr === "F") fCount++;
                if (person.ftStr === "T") tCount++;
                if (person.jpStr === "J") jCount++;
                if (person.jpStr === "P") pCount++;
            });

            const total = allData.length;
            const iPercent = Math.round((iCount / total) * 100);
            const ePercent = Math.round((eCount / total) * 100);
            const nPercent = Math.round((nCount / total) * 100);
            const sPercent = Math.round((sCount / total) * 100);
            const fPercent = Math.round((fCount / total) * 100);
            const tPercent = Math.round((tCount / total) * 100);
            const jPercent = Math.round((jCount / total) * 100);
            const pPercent = Math.round((pCount / total) * 100);

            // Find most common mistype
            const mistypes = {};
            allData.forEach(person => {
                if (person.mbtiType !== MyMBTI) {
                    mistypes[person.mbtiType] = (mistypes[person.mbtiType] || 0) + 1;
                }
            });

            let mostCommonMistype = "None";
            const entries = Object.entries(mistypes);
            if (entries.length > 0) {
                const maxValue = Math.max(...entries.map(([_, val]) => val));
                const topTypes = entries.filter(([_, val]) => val === maxValue).map(([key]) => key);
                mostCommonMistype = topTypes.length === 1 ? topTypes[0] : topTypes.join(", ");
            }


            // Calculate average traits for comparison chart
            let avgIE = 0, avgNS = 0, avgFT = 0, avgJP = 0;
            allData.forEach(person => {
                avgIE += person.ie;
                avgNS += person.ns;
                avgFT += person.ft;
                avgJP += person.jp;
            });

            avgIE /= allData.length;
            avgNS /= allData.length;
            avgFT /= allData.length;
            avgJP /= allData.length;

            // Calculate perception by relationship
            const relationshipPerception = {};
            allData.forEach(person => {
                const rel = person.relationshipType;
                if (!relationshipPerception[rel]) {
                    relationshipPerception[rel] = {
                        types: {},
                        count: 0
                    };
                }
                relationshipPerception[rel].count++;
                relationshipPerception[rel].types[person.mbtiType] =
                    (relationshipPerception[rel].types[person.mbtiType] || 0) + 1;
            });

            // Update UI
            updateSummary(allData.length, allData.filter(p => p.mbtiType !== MyMBTI).length,
                mostCommonMistype, iPercent, ePercent, nPercent, sPercent,
                fPercent, tPercent, jPercent, pPercent);

            filterConfigs.forEach(({ key, selectId }) => {
                const sel = document.getElementById(selectId);
                // 先清一下：保留第一个“All”，删掉其余旧 option
                while (sel.options.length > 1) sel.remove(1);

                // 取该字段的所有唯一值
                const uniques = Array.from(new Set(
                    allData.map(p => p[key] != null ? p[key] : 'Unknown')
                ));

                // 如果全是数字则按数字排，否则按字符串排
                const allNums = uniques.every(v => typeof v === 'number');
                uniques.sort((a, b) => {
                    if (allNums) return a - b;
                    return String(a).localeCompare(String(b));
                });

                uniques.forEach(v => {
                    const opt = document.createElement('option');
                    opt.value = v;           // 保留原值（数字也 OK）
                    const str = String(v);   // 先转字符串
                    opt.text = str
                        .replace(/_/g, ' ')
                        .replace(/\b\w/g, c => c.toUpperCase());
                    sel.appendChild(opt);
                });
            });
            // —— 填充完成 ——
            // drawMBTINetworkChart(mbtiCounts);
            // drawMBTINetworkChart();
            //updateFilterSections();
            drawFigure(mbtiCounts);
            filterConfigs.forEach(({ selectId }) => {
                const sel = document.getElementById(selectId);
                sel.removeEventListener('change', onFilterChange);
                sel.addEventListener('change', onFilterChange);
            });
            updateCombinedRadar();

        }
        // mbti_heatmap_radial.js
        // 极坐标 MBTI 热力图：层级显示差异，颜色表示误认比例，大小表示人数，支持悬浮提示
        // 文本美化：统一 Poppins 字体，适当加粗和间距，提高可读性

        let clickCount = 0;
        let activeNodesSet = new Set();
        let lastClickedNode = "none";
        function drawFigure(mbtiCounts) {
    // 基础尺寸 - 调整图表尺寸
    const baseWidth = 400;
    const baseHeight = 400; // 增加高度以适应更多内容
    const marginTop = 10;  // 减少顶部边距
    const marginLeft = 60;
    const width = baseWidth;
    const height = baseHeight;

    // 清空之前的图表
    d3.select('#mbtiSankeyChart').selectAll('*').remove();

    // 创建 SVG，统一字体
    const svg = d3.select('#mbtiSankeyChart')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('font-family', 'Poppins, sans-serif')
        .style('font-weight', 'bold');

    // 真实类型与计数
    const MyMBTI = (new URLSearchParams(window.location.search).get('mbti') || 'INFP').toUpperCase();
    const allTypes = ['ISTJ', 'ISFJ', 'INFJ', 'INTJ', 'ISTP', 'ISFP', 'INFP', 'INTP', 'ESTP', 'ESFP', 'ENFP', 'ENTP', 'ESTJ', 'ESFJ', 'ENFJ', 'ENTJ'];

    // 数据统计
    const total = d3.sum(allTypes, t => mbtiCounts[t] || 0);

    // 找出出现最多的类型及其数量
    const maxType = d3.max(allTypes, t => mbtiCounts[t] || 0);

    // 计算最多的类型占整体的百分比
    const max_ratio = maxType / total;
    
    // 使用更优美的颜色渐变 - 多彩配色方案

    // 绿色-黄色-红色渐变的颜色比例尺
const colorScale = d3.scaleSequential()
    .domain([0, max_ratio]) 
    .interpolator(t => {
        // t值小于0.5时，从绿色过渡到黄色
        // t值大于0.5时，从黄色过渡到红色
        if (t < 0.5) {
            // 0-0.5范围映射到绿色-黄色
            const normalizedT = t * 2; // 将0-0.5映射到0-1
            return d3.interpolateRgb('rgb(30, 150, 0)', 'rgb(255, 242, 0)')(normalizedT);
        } else {
            // 0.5-1范围映射到黄色-红色
            const normalizedT = (t - 0.5) * 2; // 将0.5-1映射到0-1
            return d3.interpolateRgb('rgb(255, 242, 0)', 'rgb(255, 0, 0)')(normalizedT);
        }
    })
    .clamp(true);

    // 创建发光效果
    const defs = svg.append('defs');
    
    // 添加发光滤镜
    const filter = defs.append('filter')
        .attr('id', 'glow')
        .attr('x', '-50%')
        .attr('y', '-50%')
        .attr('width', '200%')
        .attr('height', '200%');
    
    // 添加模糊效果
    filter.append('feGaussianBlur')
        .attr('stdDeviation', '2.5')
        .attr('result', 'coloredBlur');
    
    // 合并原始图形和模糊效果
    const feMerge = filter.append('feMerge');
    feMerge.append('feMergeNode')
        .attr('in', 'coloredBlur');
    feMerge.append('feMergeNode')
        .attr('in', 'SourceGraphic');

    // 主分组位移
    const g = svg.append('g')
        .attr('transform', `translate(${marginLeft},${marginTop + 40})`); // 额外偏移，为标题腾出空间

    // 汉明距离计算
    function hammingDistance(a, b) {
        let distance = 0;
        for (let i = 0; i < 4; i++) {
            if (a[i] !== b[i]) distance++;
        }
        return distance;
    }

    // 节点大小计算
    function calculateNodeSize(ratio) {
        // 小于1%的节点也要有最小尺寸
        if (ratio < 0.01) return 8;  
        // 使用平方根比例尺以更好地显示较小比例
        return 8 + Math.sqrt(ratio * 100) * 4;
    }

    // 根据汉明距离对类型进行分组
    function groupByHammingDistance() {
        const grouped = [[], [], [], [], []];
        
        // 自己的类型放在第一组
        grouped[0].push({
            type: MyMBTI,
            ratio: (mbtiCounts[MyMBTI] || 0) / total,
            diff: 0
        });
        
        // 其他类型按汉明距离分组
        allTypes.forEach(type => {
            if (type === MyMBTI) return; // 跳过自己的类型
            
            const diff = hammingDistance(type, MyMBTI);
            const ratio = (mbtiCounts[type] || 0) / total;
            
            grouped[diff].push({
                type: type,
                ratio: ratio,
                diff: diff
            });
        });
        
        return grouped;
    }

    // 绘制图例
    function drawLegend() {
        const legendH = 180;
        const legendG = svg.append('g')
            .attr('transform', `translate(${width - 60},${marginTop + 50})`);
        
        // 创建渐变色定义
        // 创建渐变色定义 - 从黑色到黄色
        const grad = defs.append('linearGradient')
            .attr('id', 'lg')
            .attr('x1', '0%').attr('y1', '100%')
            .attr('x2', '0%').attr('y2', '0%');
           // 绿色-黄色-红色渐变
        grad.append('stop').attr('offset', '0%').attr('stop-color', 'rgb(30, 150, 0)');    // 绿色
        grad.append('stop').attr('offset', '50%').attr('stop-color', 'rgb(255, 242, 0)');  // 黄色
        grad.append('stop').attr('offset', '100%').attr('stop-color', 'rgb(255, 0, 0)');   // 红色
        // 绘制图例矩形
        legendG.append('rect')
            .attr('width', 8)
            .attr('height', legendH)
            .style('fill', 'url(#lg)')
            .style('fill-opacity', 0.8)  // 半透明
            .style('stroke', 'rgba(255,255,255,0.5)')  // 白色边框
            .style('stroke-width', 1)
            .attr('filter', 'url(#glow)');  // 应用发光效果
            
        // 创建比例尺和坐标轴
        const ls = d3.scaleLinear().domain([0, max_ratio]).range([legendH, 0]);
        const maxTick = Math.ceil(max_ratio * 100) / 100;

        // 计算等距刻度值
        const tickStep = maxTick / 4;
        const ticks = [];
        for (let i = 0; i <= 4; i++) {
            ticks.push(Math.round(i * tickStep * 100) / 100);
        }
        
        const laxis = d3.axisRight(ls)
            .tickValues(ticks)
            .tickFormat(d3.format('.0%'));
        const axisG = legendG.append('g')
            .attr('transform', 'translate(10,0)')
            .call(laxis);
        axisG.selectAll('text')
            .attr('fill', '#333')
            .attr('font-size', '9px')
            .attr('font-weight', '500');
            
        // 图例标题
        legendG.append('text')
            .attr('x', -10)
            .attr('y', -10)
            .attr('text-anchor', 'start')
            .attr('font-size', '12px')
            .attr('font-weight', 'bold')
            .text('Percentage');
    }

    // 绘制列标题
    function drawColumnHeaders() {
        const titles = [
            ' Your Type',
            '1 diff',
            '2 diffs',
            '3 diffs',
            '4 diffs'
        ];
        
        // 将标题移到SVG顶部
        const columnWidth = (baseWidth - marginLeft - 80) / 5;
        
        // 创建标题行
        const titleGroup = svg.append('g')
            .attr('transform', `translate(${marginLeft}, 20)`);
        
        titles.forEach((title, i) => {
            titleGroup.append('text')
                .attr('x', i * columnWidth + columnWidth / 2)
                .attr('y', 0)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('font-weight', 'bold')
                .text(title);
        });
    }
    
    // 绘制 MBTI 类型圆圈和文本
    function renderMBTICircles() {
        const columnWidth = (baseWidth - marginLeft - 80) / 5;
        const groupedTypes = groupByHammingDistance();
        
        // 计算每列内容的垂直分布
        for (let diffIndex = 0; diffIndex < groupedTypes.length; diffIndex++) {
            const group = groupedTypes[diffIndex];
            
            // 各列高度约束 - 使用可变高度处理大量类型
            const columnHeight = baseHeight - 100;
            
            // 计算垂直间距 - 增加间隔因子1.5使圆圈间距更大
            // 允许最大使用列高度的85%，这样上下都会留出空间
            const totalGroupHeight = Math.min(columnHeight * 0.85, group.length * 60);
            const verticalSpacing = group.length > 1 ? totalGroupHeight / (group.length - 1) : 0;
            
            // 确保第一列（我的类型）居中显示
            let startY = 0;
            if (diffIndex === 0) {
                startY = columnHeight / 2; // 居中
            } else {
                // 计算起始位置以居中整组节点
                startY = (columnHeight - totalGroupHeight) / 2;
            }
            
            // 更新布局 - 根据组内项目数量自动调整分布
            group.forEach((typeInfo, typeIndex) => {
                // 计算Y坐标 - 自动在可用空间内均匀分布
                let nodeY;
                if (group.length === 1) {
                    nodeY = columnHeight / 2; // 单个节点居中
                } else {
                    nodeY = startY + typeIndex * verticalSpacing;
                }
                const nodeX = diffIndex * columnWidth + columnWidth / 2;
                
                // 设置节点位置
                typeInfo.x = nodeX;
                typeInfo.y = nodeY;
            });
        }
        
        // 绘制每一列的类型
        // groupedTypes.forEach((group, diffIndex) => {
        //     // 绘制当前组的所有类型
        //     group.forEach((typeInfo) => {
        //         const nodeSize = calculateNodeSize(typeInfo.ratio);
        //         const isMyType = typeInfo.type === MyMBTI;
                
        //         // 创建节点组以便于添加悬停效果
        //         const nodeGroup = g.append('g')
        //             .attr('class', `mbti-node-group diff-${diffIndex}`);
                
        //         // 绘制圆圈
        //         nodeGroup.append('circle')
        //             .attr('class', `mbti-node diff-${diffIndex}`)
        //             .attr('cx', typeInfo.x)
        //             .attr('cy', typeInfo.y)
        //             .attr('r', nodeSize)
        //             .attr('fill', colorScale(typeInfo.ratio))
        //             .attr('fill-opacity', 0.8)  // 设置半透明填充
        //             .attr('stroke', isMyType ? '#fff' : 'rgba(255,255,255,0.5)')  // 白色边框，自己的类型更明显
        //             .attr('stroke-width', isMyType ? 2 : 1)
        //             .attr('filter', 'url(#glow)')  // 应用发光效果
        //             .style('transition', 'all 0.3s ease')
        //             .on('mouseover', function() {
        //                 d3.select(this)
        //                     .transition()
        //                     .duration(300)
        //                     .attr('r', nodeSize * 1.3)
        //                     .attr('fill-opacity', 1.0);  // 悬停时变为不透明
                            
        //                 // 显示百分比标签
        //                 d3.select(`#percent-${typeInfo.type}`)
        //                     .style('opacity', 1);
        //             })
        //             .on('mouseout', function() {
        //                 d3.select(this)
        //                     .transition()
        //                     .duration(300)
        //                     .attr('r', nodeSize)
        //                     .attr('fill-opacity', 0.8);  // 恢复半透明
                            
        //                 // 隐藏百分比标签
        //                 d3.select(`#percent-${typeInfo.type}`)
        //                     .style('opacity', 0);
        //             });
                
        //         // 添加百分比提示文本 (初始隐藏)
        //         nodeGroup.append('text')
        //             .attr('id', `percent-${typeInfo.type}`)
        //             .attr('x', typeInfo.x)
        //             .attr('y', typeInfo.y - nodeSize - 5)
        //             .attr('text-anchor', 'middle')
        //             .attr('font-size', '11px')
        //             .attr('font-weight', 'bold')
        //             .attr('fill', '#fff')  // 白色文字更醒目
        //             .attr('stroke', 'rgba(0,0,0,0.5)')  // 添加黑色描边增加可读性
        //             .attr('stroke-width', 0.5)
        //             .style('opacity', 0)  // 初始隐藏
        //             .style('pointer-events', 'none')  // 防止干扰鼠标事件
        //             .style('transition', 'opacity 0.3s ease')
        //             .text(`${(typeInfo.ratio * 100).toFixed(1)}%`);
                
        //         // 绘制类型文本标签
                
                
        //         // 为我的类型添加星星标记
        //         if (isMyType) {
        //             nodeGroup.append('text')
        //                 .attr('x', typeInfo.x)
        //                 .attr('y', typeInfo.y - nodeSize - 15)
        //                 .attr('text-anchor', 'middle')
        //                 .attr('font-size', '16px')
        //                 .attr('fill', '#FFD700')  // 更亮的金色星星
        //                 .attr('filter', 'url(#glow)')  // 星星也发光
        //                 .text('⭐');
        //         }

        //         nodeGroup.append('text')
        //             .attr('class', 'mbti-label')
        //             .attr('x', typeInfo.x)
        //             .attr('y', typeInfo.y + nodeSize + 10)  // 文本放在圆圈下方
        //             .attr('text-anchor', 'middle')
        //             .attr('dy', '0.35em')
        //             .attr('font-size', '13px') 
        //             .attr('font-weight', 'bold')
        //             .text(typeInfo.type);
        //     });
        // });
    // 首先绘制所有圆圈
            groupedTypes.forEach((group, diffIndex) => {
                group.forEach((typeInfo) => {
                    const nodeSize = calculateNodeSize(typeInfo.ratio);
                    const isMyType = typeInfo.type === MyMBTI;
                    
                    // 创建节点组
                    const nodeGroup = g.append('g')
                        .attr('class', `mbti-node-group diff-${diffIndex}`);
                    
                    // 绘制圆圈
                    nodeGroup.append('circle')
                        .attr('class', `mbti-node diff-${diffIndex}`)
                        .attr('cx', typeInfo.x)
                        .attr('cy', typeInfo.y)
                        .attr('r', nodeSize)
                        .attr('fill', colorScale(typeInfo.ratio))
                        .attr('fill-opacity', 0.6)
                        .attr('stroke', isMyType ? '#fff' : 'rgba(255,255,255,0.5)')
                        .attr('stroke-width', isMyType ? 2 : 1)
                        .attr('filter', 'url(#glow)')
                        .style('transition', 'all 0.3s ease')
                        .on('mouseover', function() {
                            d3.select(this)
                                .transition()
                                .duration(300)
                                .attr('r', nodeSize * 1.3)
                                .attr('fill-opacity', 1.0);
                            // 显示百分比标签
                            d3.select(`#percent-${typeInfo.type}`)
                                .style('opacity', 1);
                        })
                        .on('mouseout', function() {
                            d3.select(this)
                                .transition()
                                .duration(300)
                                .attr('r', nodeSize)
                                .attr('fill-opacity', 0.8);
                            
                            // 隐藏百分比标签
                            d3.select(`#percent-${typeInfo.type}`)
                                .style('opacity', 0);
                        });
                });
            });

            // 然后绘制所有文字标签，确保它们在所有圆圈的上方
            groupedTypes.forEach((group, diffIndex) => {
                group.forEach((typeInfo) => {
                    const nodeSize = calculateNodeSize(typeInfo.ratio);
                    const isMyType = typeInfo.type === MyMBTI;
                    
                    // 创建文字分组
                    const textGroup = g.append('g')
                        .attr('class', `mbti-text-group diff-${diffIndex}`);
                    
                    // 添加百分比提示文本
                    textGroup.append('text')
                        .attr('id', `percent-${typeInfo.type}`)
                        .attr('x', typeInfo.x)
                        .attr('y', typeInfo.y - nodeSize/2) // 文本放在圆圈下方
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '11px')
                        .attr('font-weight', 'bold')
                        .attr('fill', 'rgb(101, 78, 163)')
                        .attr('stroke', 'rgba(0,0,0,0.5)')
                        .attr('stroke-width', 0.5)
                        .style('opacity', 0)
                        .style('pointer-events', 'none')
                        .style('transition', 'opacity 0.3s ease')
                        .text(`${(typeInfo.ratio * 100).toFixed(1)}%`);
                    
                    // 为我的类型添加星星标记
                    if (isMyType) {
                        textGroup.append('text')
                            .attr('x', typeInfo.x)
                            .attr('y', typeInfo.y - nodeSize )
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '16px')
                            .attr('fill', '#FFD700')
                            .attr('filter', 'url(#glow)')
                            .text('⭐');
                    }
                    
                    // 绘制类型文本标签
                    textGroup.append('text')
                        .attr('class', 'mbti-label')
                        .attr('x', typeInfo.x)
                        .attr('y', typeInfo.y + nodeSize +4 )
                        .attr('text-anchor', 'middle')
                        .attr('dy', '0.35em')
                        .attr('font-size', '13px')
                        .attr('font-weight', 'bold')
                        .text(typeInfo.type);
                });
            });
    }
    // 执行绘图
    drawColumnHeaders();
    drawLegend();
    renderMBTICircles();
}
    
function onFilterChange(e) {
            updateSelectDisabling(e.target.id);
            updateCombinedRadar();
        }
        // 1. 正确的差异计算函数
        function getDimensionDiff(base, other) {
            let diff = 0;
            for (let i = 0; i < 4; i++) {
                if (base[i] !== other[i]) diff++;
            }
            return diff;
        }
        const filterConfigs = [
            { key: 'relationshipType', selectId: 'filterRelType' },
            { key: 'sinceWhen', selectId: 'filterSinceWhen' },
            // { key: 'familiarity', selectId: 'filterFamiliarity' },
            { key: 'interactionPlace', selectId: 'filterInteraction' }
        ];
        let combinedChart = null;

        // 禁用已选项于其它下拉框
        function updateSelectDisabling(changedId) {
            const sel = document.getElementById(changedId);
            const val = sel.value;
            filterConfigs.forEach(({ selectId }) => {
                if (selectId === changedId) return;
                const other = document.getElementById(selectId);
                Array.from(other.options).forEach(opt => {
                    opt.disabled = (opt.value === val && val !== 'all');
                    // 如果当前值被禁，就重置为 all
                    if (opt.disabled && other.value === val) other.value = 'all';
                });
            });
        }
        let mbtiNetworkChart = null;


        function updateCombinedRadar() {
            // 计算所有筛选组合的准确度
            const groupPerceptions = [];

            // 遍历三个筛选条件的所有可能值
            filterConfigs.forEach(filter => {
                // 获取当前筛选条件的所有选项值（除了"all"）
                const select = document.getElementById(filter.selectId);
                const options = Array.from(select.options)
                    .filter(opt => opt.value !== 'all')
                    .map(opt => opt.value);
                // 对每个选项计算感知准确度
                options.forEach(optionValue => {
                    // 设置其他筛选条件为"all"
                    const filteredData = allData.filter(p => {
                        // 如果filter.key是数值类型字段，将两边都转为字符串比较
                        if (typeof p[filter.key] === 'number') {
                            return String(p[filter.key]) === String(optionValue);
                        }
                        // 其他情况直接比较
                        return p[filter.key] === optionValue;
                    });
                    // 如果该组没有数据，则跳过
                    if (filteredData.length === 0) {
                        return;
                    }

                    const total = filteredData.length;
                    const eCnt = filteredData.filter(p => p.ieStr === 'E').length;
                    const nCnt = filteredData.filter(p => p.nsStr === 'N').length;
                    const fCnt = filteredData.filter(p => p.ftStr === 'F').length;
                    const jCnt = filteredData.filter(p => p.jpStr === 'J').length;
                    const MBTI = MyMBTI.split('');

                    // 计算四个维度的感知百分比
                    const iePct = MBTI[0] === 'I' ? Math.round((total - eCnt) / total * 100) : Math.round(eCnt / total * 100);
                    const nsPct = MBTI[1] === 'N' ? Math.round(nCnt / total * 100) : Math.round((total - nCnt) / total * 100);
                    const ftPct = MBTI[2] === 'F' ? Math.round(fCnt / total * 100) : Math.round((total - fCnt) / total * 100);
                    const jpPct = MBTI[3] === 'J' ? Math.round(jCnt / total * 100) : Math.round((total - jCnt) / total * 100);

                    // 计算感知维度匹配的数量
                    let correctDimensions = 0;
                    if (iePct >= 50) correctDimensions++;
                    if (nsPct >= 50) correctDimensions++;
                    if (ftPct >= 50) correctDimensions++;
                    if (jpPct >= 50) correctDimensions++;

                    // 计算感知的平均准确度
                    const avgPerception = (iePct + nsPct + ftPct + jpPct) / 4;

                    // 计算组的平均印象 MBTI 类型
                    const avgImpressionType = calculateImpressionType(filteredData);
                    
                    // 添加到组感知数组
                    groupPerceptions.push({
                        filterType: filter.key,
                        filterValue: optionValue,
                        displayName: optionValue.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
                        correctDimensions,
                        avgPerception,
                        impressionType: avgImpressionType, // 添加平均印象类型
                        dimensions: [iePct, nsPct, ftPct, jpPct]
                    });
                });
            });

            // 按正确维度数量和平均感知百分比排序
            groupPerceptions.sort((a, b) => {
                if (b.correctDimensions !== a.correctDimensions) {
                    return b.correctDimensions - a.correctDimensions;
                }
                return b.avgPerception - a.avgPerception;
            });

            // 获取最准确的三个群体和最不准确的三个群体
            const mostAccurate = groupPerceptions.slice(0, 3);
            const leastAccurate = groupPerceptions.slice(-3).reverse();

            // 创建并显示准确度报告
            // 更新或创建准确度报告元素
            const accuracyReportElem = document.getElementById('accuracy-report');

            let reportContent = `
        <div style="margin: 0 0 0 30px; padding: 15px 20px; background-color: #f8f9fa; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.0); border-left: 4px solid ; font-family: 'Poppins', Arial, sans-serif;margin-bottom : 10px">
            <h3 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600;">Groups Most Accurately Identifying Your MBTI Type:</h3>
            <ul style="margin: 0 0 20px 0; padding-left: 25px; list-style-type: disc;">
                ${mostAccurate.map(group => {
                    const dimensionColor = group.correctDimensions === 4 ? '#4CAF50' : '#4CAF50';
                    const impressionTypeHtml = formatImpressionType(group.impressionType, MyMBTI);
                    return `<li style="margin-bottom: 8px; line-height: 1.4;">
                        <span style="color: ${dimensionColor}; font-weight: 600;">${group.displayName}
                      
                        <span style="color: #555; "> - Average impression: ${impressionTypeHtml}, Average accuracy: ${group.avgPerception.toFixed(1)}%</span>
                    </li>`;
                }).join('')}
            </ul>
            
            <h3 style="margin: 0 0 15px 0; color: #333; font-size: 16px; font-weight: 600; border-top: 1px solid #e0e0e0; padding-top: 15px;">Groups Least Accurately Identifying Your MBTI Type:</h3>
            <ul style="margin: 0; padding-left: 25px; list-style-type: disc;">
                ${leastAccurate.map(group => {
                    const dimensionColor = group.correctDimensions === 4 ? '#F44336' : '#F44336';
                    const impressionTypeHtml = formatImpressionType(group.impressionType, MyMBTI);
                    return `<li style="margin-bottom: 8px; line-height: 1.4;">
                        <span style="color: ${dimensionColor}; font-weight: 600;">${group.displayName}</span> - 
                        <span style="color: #555; ">Average impression: ${impressionTypeHtml}, Average accuracy: ${group.avgPerception.toFixed(1)}%</span>
                    </li>`;
                }).join('')}
            </ul>
            <p style="margin: 20px 0 0 0; font-style: italic; color: #666; font-size: 13px; text-align: center; padding-top: 15px; border-top: 1px dashed #e0e0e0;">
                You can explore and discover more by selecting different filters below. You can only select one value for one filter at a time.
            </p>
        </div>
        `;

            // 更新报告内容
            accuracyReportElem.innerHTML = reportContent;
            // 插入到雷达图之前
            const radarWrapper = document.querySelector('.filter-container');
            radarWrapper.parentNode.insertBefore(accuracyReportElem, radarWrapper);

            // 以下是原来的雷达图绘制代码
            // 找到唯一一个非 all 筛选
            const active = filterConfigs
                .map(c => ({ ...c, value: document.getElementById(c.selectId).value }))
                .filter(c => c.value !== 'all')[0] || null;

            // 过滤数据
            let subset = allData;
            let label = 'All';
            if (active) {
                subset = allData.filter(p => p[active.key] === active.value);
                label = active.value.replace(/_/g, ' ')
                    .replace(/\b\w/g, c => c.toUpperCase());
            }

            const total = subset.length || 1;
            const eCnt = subset.filter(p => p.ieStr === 'E').length;
            const nCnt = subset.filter(p => p.nsStr === 'N').length;
            const fCnt = subset.filter(p => p.ftStr === 'F').length;
            const jCnt = subset.filter(p => p.jpStr === 'J').length;
            const MBTI = MyMBTI.split('');

            const iePct = MBTI[0] === 'I' ? Math.round((total - eCnt) / total * 100) : Math.round(eCnt / total * 100);
            const nsPct = MBTI[1] === 'N' ? Math.round(nCnt / total * 100) : Math.round((total - nCnt) / total * 100);
            const ftPct = MBTI[2] === 'F' ? Math.round(fCnt / total * 100) : Math.round((total - fCnt) / total * 100);
            const jpPct = MBTI[3] === 'J' ? Math.round(jCnt / total * 100) : Math.round((total - jCnt) / total * 100);

            // 颜色映射
            const colorMap = {
                relationshipType: '#4a6fa5',
                sinceWhen: '#28a745',
                filterFamiliarity: '#8a4fff',
                interactionPlace: '#ff8f2e',
                all: '#e9634a'
            };
            const key = active ? active.key : 'all';
            const borderColor = colorMap[key];
            const backgroundColor = borderColor + '33'; // 加上 20% 透明度

            const dataset = {
                label,
                data: [iePct, nsPct, ftPct, jpPct],
                borderColor,
                backgroundColor,
                fill: true,
                borderWidth: 2
            };

            const ctx = document.getElementById('combinedRadar').getContext('2d');
            if (combinedChart) combinedChart.destroy();
            combinedChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: MBTI,
                    datasets: [dataset]
                },
                options: {
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { stepSize: 20 }
                        }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' }
                    },
                    elements: {
                        line: { tension: 0.3 }
                    }
                }
            });
        }

        // 计算群体的平均印象 MBTI 类型
        function calculateImpressionType(data) {
            if (!data || data.length === 0) return 'XXXX'; // 没有数据时返回占位符
            
            // 统计 I/E 维度
            const eCnt = data.filter(p => p.ieStr === 'E').length;
            const iCnt = data.length - eCnt;
            const ieDimension = eCnt > iCnt ? 'E' : 'I';
            
            // 统计 N/S 维度
            const nCnt = data.filter(p => p.nsStr === 'N').length;
            const sCnt = data.length - nCnt;
            const nsDimension = nCnt > sCnt ? 'N' : 'S';
            
            // 统计 F/T 维度
            const fCnt = data.filter(p => p.ftStr === 'F').length;
            const tCnt = data.length - fCnt;
            const ftDimension = fCnt > tCnt ? 'F' : 'T';
            
            // 统计 J/P 维度
            const jCnt = data.filter(p => p.jpStr === 'J').length;
            const pCnt = data.length - jCnt;
            const jpDimension = jCnt > pCnt ? 'J' : 'P';
            
            // 组合形成完整的 MBTI 类型
            return ieDimension + nsDimension + ftDimension + jpDimension;
        }

        // 格式化印象类型，使得与 MyMBTI 一致的维度显示为绿色，不一致的显示为红色
        function formatImpressionType(impressionType, myMBTI) {
            if (!impressionType || impressionType === 'XXXX') return 'Unknown';
            
            const impressionChars = impressionType.split('');
            const myMBTIChars = myMBTI.split('');
            
            let formattedType = '';
            
            for (let i = 0; i < 4; i++) {
                const color = impressionChars[i] === myMBTIChars[i] ? '#4CAF50' : '#F44336';
                formattedType += `<span style="color: ${color}; font-weight: 600;">${impressionChars[i]}</span>`;
            }
            
            return formattedType;
        }


        function updateSummary(totalCount, mistypeCount, mostCommonMistype,
            iPercent, ePercent, nPercent, sPercent,
            fPercent, tPercent, jPercent, pPercent) {


            const summaryElem = document.querySelector(".summary-title");

            if (mistypeCount === 0) {
                summaryElem.innerHTML = `<span class="mbti-highlight" style=" color: #4CAF50;">Everyone</span> perceived you as your type.`;
            } else {
                summaryElem.innerHTML =
                    `<span class="mbti-highlight" style=" color: #F44336;">${mistypeCount}</span> out of <span class="mbti-highlight" style=" color: #F44336;">${totalCount}</span> people perceive you 
                    <span class="mbti-highlight" style=" color: #F44336;">not your type</span>, 
                    the most common mistypes are <span class="mbti-highlight"  style=" color: #F44336;">${mostCommonMistype}.</span> 

                    `;
            }

            const summaryList = document.querySelector(".summary-list");
            summaryList.innerHTML = `<li><canvas id="summaryChart" width="400" height="400"></canvas></li>`;
            // Determine the four core percentages based on your MBTI
            const dataPoints = [
                MyMBTI[0] === 'I' ? iPercent : ePercent,
                MyMBTI[1] === 'N' ? nPercent : sPercent,
                MyMBTI[2] === 'F' ? fPercent : tPercent,
                MyMBTI[3] === 'J' ? jPercent : pPercent
            ];
            // 更新图表标题，添加维度百分比解释，使用项目符号列表并高亮百分比
            const perceptionDimensionElem = document.querySelector(".chart-title");

            // 获取用户的MBTI类型的各个维度
            const iDim = MyMBTI[0];
            const sDim = MyMBTI[1];
            const tDim = MyMBTI[2];
            const jDim = MyMBTI[3];
            const getOpposite = (letter) => {
                const opposites = {
                    'I': 'E', 'E': 'I',
                    'N': 'S', 'S': 'N',
                    'F': 'T', 'T': 'F',
                    'J': 'P', 'P': 'J'
                };
                return opposites[letter] || letter;
            };
            // 确定每对维度中百分比较高的一个
            const firstLetter = dataPoints[0] >= 50 ? MyMBTI[0] : getOpposite(MyMBTI[0]);
            const secondLetter = dataPoints[1] >= 50 ? MyMBTI[1] : getOpposite(MyMBTI[1]);
            const thirdLetter = dataPoints[2] >= 50 ? MyMBTI[2] : getOpposite(MyMBTI[2]);
            const fourthLetter = dataPoints[3] >= 50 ? MyMBTI[3] : getOpposite(MyMBTI[3]);
            // 组合成完整的MBTI类型
            const perceivedType = firstLetter + secondLetter + thirdLetter + fourthLetter;

            // 创建带项目符号和高亮的百分比文字说明
            perceptionDimensionElem.innerHTML = `
  <div style=" text-align: left;">
    <div >
      People's average impression of you is <span class="mbti-highlight" style="color: ${perceivedType === MyMBTI ? '#4CAF50' : '#F44336'}">${perceivedType}.</span>
    </div>
    <div>
      <span class="mbti-highlight" style="color: #4CAF50;">${dataPoints[0]}%</span> people correctly perceive your ${MyMBTI[0]} dimension, 
      <span class="mbti-highlight" style=" color: #4CAF50;">${dataPoints[1]}%</span> your ${MyMBTI[1]} dimension, 
      <span class="mbti-highlight" style="color: #4CAF50;">${dataPoints[2]}%</span> your ${MyMBTI[2]} dimension, 
      <span class="mbti-highlight" style=" color: #4CAF50;">${dataPoints[3]}%</span> your ${MyMBTI[3]} dimension.
    </div> 
  </div>
`;
            const ctx = document.getElementById('summaryChart').getContext('2d');
            // Destroy existing chart if present
            if (window.summaryRadar) window.summaryRadar.destroy();

            // Create the radar chart
            window.summaryRadar = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: [MyMBTI[0], MyMBTI[1], MyMBTI[2], MyMBTI[3]],
                    datasets: [{
                        label: '% of matching perceptions: ',
                        data: dataPoints,
                        backgroundColor: 'rgba(76, 175, 80, 0.4)',
                        borderColor: '#4CAF50',
                        pointBackgroundColor: '#4CAF50',
                        pointBorderColor: '#fff',
                        pointRadius: 3,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { stepSize: 20, font: { size: 10 } },
                            grid: { color: '#e0e0e0' },
                            angleLines: { color: '#e0e0e0' },
                            pointLabels: {
                                font: { family: 'Poppins', size: 20 },
                                color: '#4CAF50'
                            }
                        }
                    },
                    plugins: { legend: { display: false } },
                    elements: { line: { tension: 0.3 } },
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }

        function updateFilterSections() {
            console.log('⚙️ updateFilterSections() called');
            const filters = [
                { key: 'relationshipType', sectionId: 'relationshipTypeSection' },
                { key: 'sinceWhen', sectionId: 'sinceWhenSection' },
                // { key: 'familiarity', sectionId: 'intimacyGraphSection' },
                { key: 'interactionPlace', sectionId: 'interactionPlaceSection' }
            ];

            filters.forEach(({ key, sectionId }) => {
                const displayName = [];
                const ieUserPct = [];
                const nsUserPct = [];
                const ftUserPct = [];
                const jpUserPct = [];
                const ul = document.getElementById(sectionId);
                // 按 filter 分组
                const groups = allData.reduce((acc, p) => {
                    const v = p[key] || 'Unknown';
                    (acc[v] = acc[v] || []).push(p);
                    return acc;
                }, {});
                Object.entries(groups).forEach(([group, list]) => {
                    if (group === 'Unknown' && list.length < 3) return;
                    const total = list.length;
                    // 计算每侧人数
                    const eCnt = list.filter(p => p.ieStr === 'E').length;
                    const iCnt = total - eCnt;
                    const nCnt = list.filter(p => p.nsStr === 'N').length;
                    const sCnt = total - nCnt;
                    const fCnt = list.filter(p => p.ftStr === 'F').length;
                    const tCnt = total - fCnt;
                    const jCnt = list.filter(p => p.jpStr === 'J').length;
                    const pCnt = total - jCnt;

                    // 基于你的 MBTI 侧计算百分比
                    ieUserPct.push(MyMBTI[0] === 'I' ? Math.round(iCnt / total * 100) : Math.round(eCnt / total * 100));
                    nsUserPct.push(MyMBTI[1] === 'N' ? Math.round(nCnt / total * 100) : Math.round(sCnt / total * 100));
                    ftUserPct.push(MyMBTI[2] === 'F' ? Math.round(fCnt / total * 100) : Math.round(tCnt / total * 100));
                    jpUserPct.push(MyMBTI[3] === 'J' ? Math.round(jCnt / total * 100) : Math.round(pCnt / total * 100));

                    displayName.push(group.replace(/_/g, ' ')
                        .replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()));
                });
                console.log(displayName);
                // 定义一个调色板（可以根据 displayName 增加颜色）
                const radarColors = ['#4a6fa5', '#28a745', '#8a4fff', '#ff8f2e', '#e9634a'];


                // 找到对应 section 下的 canvas，假设你在 HTML 里给每个 section 加了
                // <canvas id="${sectionId}Radar"></canvas>
                const canvas = document.getElementById(sectionId + 'Radar');
                const ctx = canvas.getContext('2d');

                // 构建 datasets
                const datasets = displayName.map((name, i) => ({
                    label: name,
                    data: [
                        ieUserPct[i],
                        nsUserPct[i],
                        ftUserPct[i],
                        jpUserPct[i]
                    ],
                    borderColor: radarColors[i],

                    borderWidth: 2,
                    fill: true
                }));

                // 如果已经有旧图表，把它摧毁
                if (window[sectionId + 'Chart']) {
                    window[sectionId + 'Chart'].destroy();
                }

                // 新建一个 Radar
                window[sectionId + 'Chart'] = new Chart(ctx, {
                    type: 'radar',
                    data: {
                        labels: MyMBTI.split(''),   // ['I','N','F','J']
                        datasets
                    },
                    options: {
                        scales: {
                            r: {
                                beginAtZero: true,
                                max: 100,
                                ticks: { stepSize: 20 }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        elements: {
                            line: { tension: 0.3 }
                        }
                    }
                });

            });

        }

        // Call this function after the DOM has loaded


    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f5f8fb;
            color: #333;
            margin: 0;
            padding: 30px;
        }

        .main-container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }

        .header-section {
            text-align: center;
            padding: 15px;
            border-bottom: 1px solid #eaeaea;
        }

        .header-title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        #mbti-title {
            font-size: 18px;

        }

        .summary-section {
            text-align: left;
        }

        .summary-title {
            font-size: 14px;
            margin-bottom : 0px;
        }

        .summary-list {
            list-style-type: none;
            padding-left: 0;
        }

        /* Slider styles for trait visualization */
        .trait-slider {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .trait-label {
            font-weight: bold;
            width: 20px;
            text-align: center;
            color: #203270;
        }

        .slider-container {
            flex-grow: 1;
        }

        .slider-bar {
            height: 12px;
            background-color: #e0e0e0;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
        }

        .slider-fill {
            height: 100%;
            background-color: #203270;
            border-radius: 6px 0 0 6px;
        }

        .slider-percentages {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 2px;
            color: #666;
        }


        .visualization-section {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            /* 父容器顶部对齐 */
            gap: 20px;
        }

        .chart-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* 子元素左对齐，标题和文字靠左 */
            justify-content: flex-start;
            /* 子元素从顶部开始排列 */
            width: 48%;
            /* 如果不需要固定高度，最好删掉下面这一行，让内容决定高度 */

            padding: 10px;
            box-sizing: border-box;
        }

        .chart-container .mbti-visualization {
            margin-top: 20%;
        }

        .relationship-section {
            text-align: left;
            padding: 30px 20px;
            border-top: 1px solid #eaeaea;
            background-color: #fafafa;
            margin-bottom: 20px;
        }

        .relationship-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #333;
            border-left: 4px solid #4a6fa5;
            padding-left: 12px;
        }

        .section-description {
            margin-bottom: 20px;
            color: #555;
            font-size: 14px;
            line-height: 1.5;
        }

        .section-description ul {
            padding-left: 20px;
        }

        /* Card grid layout */
        .relationship-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        /* Card styling */
        .relationship-list li {
            background: #fff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            transition: transform .2s, box-shadow .2s;
            display: flex;
            flex-direction: column;
        }

        .relationship-list li:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
        }

        /* Group name styling */
        .group-name {
            font-size: 18px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
            text-align: center;
        }

        /* Trait bars container */
        .trait-bars {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
        }

        /* Individual trait bar */
        .trait-bar {
            width: 100%;
        }

        .trait-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 13px;
            font-weight: 500;
        }

        .trait-name {
            color: #555;
        }

        .trait-percentage {
            color: #333;
            font-weight: 600;
        }

        /* Progress bar container */
        .trait-progress {
            height: 12px;
            width: 100%;
            background-color: #f0f0f0;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        /* Progress bar fill styles for each trait */
        .trait-fill {
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            border-radius: 6px;
            transition: width 0.5s ease;
        }

        /* Distinct colors for each personality dimension */

        /* Legend at the top */
        .personality-legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 24px;
            padding: 16px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-text {
            font-size: 14px;
            color: #555;
        }

        .radar-chart-wrapper {
            width: 400px;
            height: 400px;
            margin: 0 auto;
            /* 左右自动外边距，水平居中 */
        }

        /* 2. CSS */
        .filter-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;

            margin-bottom: 1rem;
        }

        .filter-item {
            position: relative;
            display: flex;
            flex-direction: column;
            font-size: 0.9rem;
            margin: 0 auto;
        }

        .filter-item label {
            margin-bottom: 0.25rem;
            color: #444;
            font-weight: 500;
        }

        /* ↓↓↓ 透明简约下拉框样式 ↓↓↓ */
        .filter-item select {
            /* 去掉系统默认样式 */
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;

            /* 半透明白背景 + 轻薄边框 */
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 4px;

            /* 内边距减小，更精致 */
            padding: 0.4rem 0.8rem;
            color: #333;
            font-size: 0.9rem;

            /* 过渡效果 */
            transition:
                background 0.2s ease,
                border-color 0.2s ease,
                box-shadow 0.2s ease;
            cursor: pointer;
        }

        .filter-item select:hover {
            /* 背景加一点不透明度 */
            background: rgba(255, 255, 255, 0.8);
        }

        .filter-item select:focus {
            outline: none;
            /* 更明显的边框 + 微弱阴影 */
            border-color: rgba(0, 0, 0, 0.3);
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
            background: rgba(255, 255, 255, 0.9);
        }

        /* 自定义箭头，颜色柔和 */
        .filter-item::after {
            content: '▾';
            position: absolute;
            top: 50%;
            right: 0.8rem;
            transform: translateY(-50%);
            pointer-events: none;
            color: rgba(0, 0, 0, 0.4);
        }

        /* 下拉选项颜色恢复原生清晰风格 */
        .filter-item select option {
            background: #fff;
            color: #333;
        }

        .radar-chart-wrapper canvas {

            width: 100% !important;
            height: 100% !important;
        }


        .chart-description,
        .section-description {
            font-size: 13px;
            color: #555;
            margin: 8px 0 12px;
        }

        .chart-description ul,
        .section-description ul {
            padding-left: 18px;
            margin: 0;
        }

        .chart-description li,
        .section-description li {
            margin-bottom: 4px;
        }

        .mbti-highlight {
            font-weight: bold;

        }

        .chart-title {
            text-align: center;

            font-size: 14px;

        }

        .mbti-visualization {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            max-width: 350px;
            margin-left: auto;
            margin-right: auto;
        }

        .mbti-type {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            border: 2px solid #8FB9D1;
            font-weight: bold;
            position: relative;
            font-size: 14px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .mbti-type.your-type {
            border: 3px solid #203270;
            background-color: #e8f4ff;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(32, 50, 112, 0.2);
        }

        #mbtiSankeyChart {
            width: 500px;
            height: 350px;
            margin: 0 auto;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s;
        }

        .node:hover {
            stroke: #59aaf0;
            stroke-width: 1px;
        }

        .active-node {
            stroke: #59aaf0;
            stroke-width: 1px;
        }

        .node-label {
            pointer-events: none;
            font-weight: 500;
        }

        .percentage-label {
            pointer-events: none;
            font-weight: 500;
            fill: #333;
        }

        .mbti-star {
            pointer-events: none;
        }

        .hidden {
            display: none;
        }

        .visible {
            display: block;
        }

        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            max-width: 300px;
            font-size: 12px;
        }

        .connection-line {
            transition: opacity 0.3s;
        }

        .diff-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 1px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 10px;
            color: #555;
        }

        .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 6px;
            border-radius: 2px;
            border: 1px solid #ccc;
        }

        .diff-indicator {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #555;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 10px;
            line-height: 1;
        }

        .mbti-type:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
            z-index: 10;
        }

        .mbti-type.your-type:hover {
            transform: scale(1.1);
        }

        .tab-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }

        .tab {
            padding: 5px 15px;
            border: 1px solid #ddd;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab.active {
            background-color: #203270;
            color: white;
            border-color: #203270;
        }

        /* Add space between different sections */
        section {
            margin-bottom: 10px;
        }
    </style>
</head>

<body>
    <div class="main-container">
        <!-- Header Section -->
        <section class="header-section">
            <div class="header-title">MBTI Perception Report</div>
            <div id="mbti-title">Your MBTI Type: Loading...</div>
        </section>

        <!-- Summary Section -->


        <!-- Visualization Section -->
        <section class="visualization-section">
            <div class="chart-container">

                <section class="summary-section">
                    <div class="summary-title">Loading data...</div>
                </section>
                <div class="radar-chart-wrapper">
                    <div id="mbtiSankeyChart"></div>
                </div>
            </div>
            <div class="chart-container">
                <div class="chart-title">Overall Trait Perception</div>
                <ul class="summary-list">
                    <li>Loading...</li>
                </ul>
            </div>
        </section>
        <div id="accuracy-report"></div>
        <!-- 1. HTML -->
        <div class="filter-container">
            <div class="filter-item">
                <label for="filterRelType">Relationship Type:</label>
                <select id="filterRelType">
                    <option value="all">All</option>
                    <!-- 根据你的数据动态插入<option value="Family">Family</option>等 -->
                </select>
            </div>
            <div class="filter-item">
                <label for="filterSinceWhen">Know Time:</label>
                <select id="filterSinceWhen">
                    <option value="all">All</option>
                    <!-- 动态插入 -->
                </select>
            </div>
            <!-- <div class="filter-item">
                <label for="filterFamiliarity">Familiarity:</label>
                <select id="filterFamiliarity">
                    <option value="all">All</option>
                </select>
            </div> -->
            <div class="filter-item">
                <label for="filterInteraction">Interaction Place:</label>
                <select id="filterInteraction">
                    <option value="all">All</option>
                    <!-- 动态插入 -->
                </select>
            </div>
        </div>

        <div class="radar-chart-wrapper">
            <canvas id="combinedRadar"></canvas>
        </div>


    </div>
    </div>
</body>

</html>