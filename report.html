<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My MBTI Report</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="switch_language.js" defer></script>
    <link rel="stylesheet" href="style3.css">
    <style>
        .chart-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            max-width: 90%;
            margin: 0 auto;
        }

        .chart-box {
            width: 45%;
            min-width: 300px;
            min-height: 250px;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .filters {
            text-align: center;
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <h1>My MBTI Report</h1>
    <p>This report shows the average MBTI perception others have of you.</p>

    <h2>Average MBTI Perception</h2>
    <p id="average-mbti">Loading...</p>

    <div class="filters">
        <label for="relationship-filter">Filter by Relationship Type:</label>
        <select id="relationship-filter">
            <option value="all">All</option>
        </select>

        <label for="interaction-filter">Filter by Interaction Place:</label>
        <select id="interaction-filter">
            <option value="all">All</option>
        </select>

        <label for="familiarity-filter">Filter by Familiarity Level:</label>
        <select id="familiarity-filter">
            <option value="all">All</option>
        </select>
    </div>

    <div class="chart-container">
        <div class="chart-box"><canvas id="chartIE"></canvas></div>
        <div class="chart-box"><canvas id="chartNS"></canvas></div>
        <div class="chart-box"><canvas id="chartFT"></canvas></div>
        <div class="chart-box"><canvas id="chartJP"></canvas></div>
    </div>

</body>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
    import { getDatabase, ref, query, orderByChild, equalTo, get } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyCvc9C5PuDqrI26jrmsg5b1PVOW6_k43W4",
        authDomain: "mbti-kale.firebaseapp.com",
        databaseURL: "https://mbti-kale-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "mbti-kale",
        storageBucket: "mbti-kale.firebasestorage.app",
        messagingSenderId: "756176954275",
        appId: "1:756176954275:web:7581e5e485e426b33ff016",
        measurementId: "G-B6F0F4JZ7E"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    const urlParams = new URLSearchParams(window.location.search);
    const username = urlParams.get("username");

    if (!username) {
        alert("Invalid access.");
        window.location.href = "index.html";
    }

    let dataPoints = [];
    let charts = {};

    async function fetchData() {
        const dbRef = ref(database, "responses");
        const q = query(dbRef, orderByChild("username"), equalTo(username));
        const snapshot = await get(q);
        if (!snapshot.exists()) {
            document.getElementById("average-mbti").textContent = "No data found.";
            return;
        }

        let totalCount = 0;
        let sumI = 0, sumE = 0, sumN = 0, sumS = 0, sumF = 0, sumT = 0, sumJ = 0, sumP = 0;
        let relationshipTypes = new Set();
        dataPoints = [];
        let interactionPlaces = new Set();
        let familiarityLevels = new Set();
        snapshot.forEach((childSnapshot) => {
            const data = childSnapshot.val();

            function parseMBTI(value) {
                let percent = parseInt(value.replace(/[^0-9]/g, ""), 10); // 解析数值
                let type = value.replace(/[0-9%]/g, "").trim(); // 解析类型
                return { percent, type };
            }

            let ieData = parseMBTI(data.ie);
            let nsData = parseMBTI(data.ns);
            let ftData = parseMBTI(data.ft);
            let jpData = parseMBTI(data.jp);
            let ieValue = ieData.type === "I" ? 50 - (ieData.percent / 2) : 50 + (ieData.percent / 2);
            let nsValue = nsData.type === "N" ? 50 - (nsData.percent / 2) : 50 + (nsData.percent / 2);
            let ftValue = ftData.type === "F" ? 50 - (ftData.percent / 2) : 50 + (ftData.percent / 2);
            let jpValue = jpData.type === "J" ? 50 - (jpData.percent / 2) : 50 + (jpData.percent / 2);

            // Add to dataset
            dataPoints.push({
                IE: ieValue,
                NS: nsValue,
                FT: ftValue,
                JP: jpValue,
                familiarity: parseInt(data.intimacyGraph) || 1,
                relationship: data.relationshipType || "Other",
                interaction: data.interactionPlace || "Other"
            });
            // 累计 I/E
            if (ieData.type === "I") sumI += ieData.percent;
            else sumE += ieData.percent;

            // 累计 N/S
            if (nsData.type === "N") sumN += nsData.percent;
            else sumS += nsData.percent;

            // 累计 F/T
            if (ftData.type === "T") sumT += ftData.percent;
            else sumF += ftData.percent;

            // 累计 J/P
            if (jpData.type === "J") sumJ += jpData.percent;
            else sumP += jpData.percent;


            totalCount++;
        });

        // 计算最终百分比
        let avgI = sumI / totalCount;
        let avgE = sumE / totalCount;
        let avgN = sumN / totalCount;
        let avgS = sumS / totalCount;
        let avgF = sumF / totalCount;
        let avgT = sumT / totalCount;
        let avgJ = sumJ / totalCount;
        let avgP = sumP / totalCount;

        // 判断最终类型
        let finalIE = avgE >= avgI ? "E" : "I";
        let finalNS = avgN >= avgS ? "N" : "S";
        let finalFT = avgT >= avgF ? "T" : "F";
        let finalJP = avgJ >= avgP ? "J" : "P";

        // 计算最终胜出的百分比
        let finalIEPercent = finalIE === "E" ? avgE + 100 / totalCount - avgI : avgI + 100 / totalCount - avgE;
        let finalNSPercent = finalNS === "N" ? avgN + 100 / totalCount - avgS : avgS + 100 / totalCount - avgN;
        let finalFTPercent = finalFT === "T" ? avgT + 100 / totalCount - avgF : avgF + 100 / totalCount - avgT;
        let finalJPPercent = finalJP === "J" ? avgJ + 100 / totalCount - avgP : avgP + 100 / totalCount - avgJ;

        // 显示最终的 MBTI 结果，保留两位小数
        document.getElementById("average-mbti").textContent =
            `${finalIE} (${finalIEPercent.toFixed(2)}%)  
     ${finalNS} (${finalNSPercent.toFixed(2)}%)  
     ${finalFT} (${finalFTPercent.toFixed(2)}%)  
     ${finalJP} (${finalJPPercent.toFixed(2)}%)`;
        populateFilterDropdowns(relationshipTypes, interactionPlaces, familiarityLevels);
        updateCharts();
    }
    function populateFilterDropdowns() {
        const relationshipFilter = document.getElementById("relationship-filter");
        const interactionFilter = document.getElementById("interaction-filter");
        const familiarityFilter = document.getElementById("familiarity-filter");

        // Clear existing options except "All"
        relationshipFilter.innerHTML = '<option value="all">All</option>';
        interactionFilter.innerHTML = '<option value="all">All</option>';
        familiarityFilter.innerHTML = '<option value="all">All</option>';

        // Add predefined relationship types
        const relationshipTypes = ["Friend", "Family", "Colleague", "Romantic", "Other"];
        relationshipTypes.forEach(type => {
            const option = document.createElement("option");
            option.value = type;
            option.textContent = type;
            relationshipFilter.appendChild(option);
        });

        // Add predefined interaction places
        const interactionPlaces = ["Online", "Work", "School", "Home", "Cafe", "Sports", "Other"];
        interactionPlaces.forEach(place => {
            const option = document.createElement("option");
            option.value = place;
            option.textContent = place;
            interactionFilter.appendChild(option);
        });

        // Add predefined intimacy levels (1-7)
        for (let level = 1; level <= 7; level++) {
            const option = document.createElement("option");
            option.value = level;
            option.textContent = `Level ${level}`;
            familiarityFilter.appendChild(option);
        };
    }
    function updateCharts() {
        const relationshipFilter = document.getElementById("relationship-filter").value;
        const interactionFilter = document.getElementById("interaction-filter").value;
        const familiarityFilter = document.getElementById("familiarity-filter").value;

        // Filter data based on selected filters
        const filteredData = dataPoints.filter(d => {
            return (relationshipFilter === "all" || d.relationship === relationshipFilter) &&
                (interactionFilter === "all" || d.interaction === interactionFilter) &&
                (familiarityFilter === "all" || d.familiarity == familiarityFilter);
        });
        ["IE", "NS", "FT", "JP"].forEach(scale => {
            drawScaleChart(`chart${scale}`, scale, filteredData, scale);
        });
    }

    function drawScaleChart(canvasId, key, data, label) {
        const ctx = document.getElementById(canvasId).getContext("2d");
        if (charts[canvasId]) charts[canvasId].destroy();

        let axisLabels = {
            "IE": "I ←→ E",
            "NS": "N ←→ S",
            "FT": "F ←→ T",
            "JP": "J ←→ P"
        };

        // Get the appropriate labels for the x-axis based on the dimension
        let leftLabel = key.charAt(0);
        let rightLabel = key.charAt(1);

        charts[canvasId] = new Chart(ctx, {
            type: "scatter",
            data: {
                datasets: [{
                    label: label,
                    data: data.map(d => ({
                        x: d[key],
                        y: Math.random() * 20 + 40, // Reduced Y-axis range
                        relationship: d.relationship, // Add relationship info for legend
                        interaction: d.interaction // Add interaction info for legend
                    })),
                    backgroundColor: data.map(d => getColorForRelationship(d.relationship)),
                    pointStyle: data.map(d => getShapeForInteraction(d.interaction)),
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                // Convert x value to show which trait is stronger
                                let value = context.parsed.x;
                                let trait = value <= 50 ? leftLabel : rightLabel;
                                let strength = value <= 50 ? 100 - value * 2 : (value - 50) * 2;
                                return `${trait}: ${Math.round(strength)}%`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        min: 0,
                        max: 100,
                        title: {
                            display: true,
                            text: axisLabels[key]
                        },
                        ticks: {
                            callback: function (value) {
                                if (value === 0) return leftLabel + " 100%";
                                if (value === 50) return "50/50";
                                if (value === 100) return rightLabel + " 100%";
                                return "";
                            }
                        }
                    },
                    y: { display: false } // Hide Y-axis
                }
            }
        });
    }


    function getAxisLabel(type) {
        return {
            "IE": "I ←→ E",
            "NS": "N ←→ S",
            "FT": "F ←→ T",
            "JP": "J ←→ P"
        }[type];
    }

    function getColorForRelationship(type) {
        return {
            "Friend": "#A3C4BC",
            "Family": "#E4C1F9",
            "Colleague": "#F4A261",
            "Romantic": "#E76F51",
            "Unknown": "#BDBDBD"
        }[type] || "black";
    }

    function getShapeForInteraction(place) {
        return {
            "Online": "circle",
            "Work": "triangle",
            "School": "rect",
            "Cafe": "star",
            "Sports": "cross"
        }[place] || "rectRot";
    }

    document.getElementById("relationship-filter").addEventListener("change", updateCharts);
    document.getElementById("interaction-filter").addEventListener("change", updateCharts);
    document.getElementById("familiarity-filter").addEventListener("change", updateCharts);

    fetchData();
</script>

</html>


<!-- <!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My MBTI Report</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="switch_language.js" defer></script>
    <link rel="stylesheet" href="style3.css">
    <style>
        .chart-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            max-width: 90%;
            margin: 0 auto;
        }

        .chart-box {
            width: 45%;
            min-width: 300px;
            min-height: 300px;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .filters {
            text-align: center;
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <h1>My MBTI Report</h1>
    <p>This report shows the average MBTI perception others have of you.</p>

    <h2>Average MBTI Perception</h2>
    <p id="average-mbti">Loading...</p>

    <div class="filters">
        <label for="relationship-filter">Filter by Relationship Type:</label>
        <select id="relationship-filter">
            <option value="all">All</option>
        </select>

        <label for="interaction-filter">Filter by Interaction Place:</label>
        <select id="interaction-filter">
            <option value="all">All</option>
        </select>

        <label for="familiarity-filter">Filter by Familiarity Level:</label>
        <select id="familiarity-filter">
            <option value="all">All</option>
        </select>
    </div>

    <div class="chart-container">
        <div class="chart-box"><canvas id="chartIE"></canvas></div>
        <div class="chart-box"><canvas id="chartNS"></canvas></div>
        <div class="chart-box"><canvas id="chartFT"></canvas></div>
        <div class="chart-box"><canvas id="chartJP"></canvas></div>
    </div>


</body>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
    import { getDatabase, ref, query, orderByChild, equalTo, get } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyCvc9C5PuDqrI26jrmsg5b1PVOW6_k43W4",
        authDomain: "mbti-kale.firebaseapp.com",
        databaseURL: "https://mbti-kale-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "mbti-kale",
        storageBucket: "mbti-kale.firebasestorage.app",
        messagingSenderId: "756176954275",
        appId: "1:756176954275:web:7581e5e485e426b33ff016",
        measurementId: "G-B6F0F4JZ7E"
    };
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    const urlParams = new URLSearchParams(window.location.search);
    let username = urlParams.get("username");
    console.log("Extracted Username:", username);
    if (!username) { alert("Invalid access."); window.location.href = "index.html"; }

    let dataPoints = [];
    let charts = {};

    async function fetchData() {
        const dbRef = ref(database, "responses");
        const q = query(dbRef, orderByChild("username"), equalTo(username));
        const snapshot = await get(q);
        if (!snapshot.exists()) { document.getElementById("average-mbti").textContent = "No data found."; return; }

        let totalCount = 0, sumIE = 0, sumNS = 0, sumFT = 0, sumJP = 0;
        snapshot.forEach((childSnapshot) => {
            const data = childSnapshot.val();
            dataPoints.push({
                IE: parseInt(data.ie), NS: parseInt(data.ns),
                FT: parseInt(data.ft), JP: parseInt(data.jp),
                familiarity: parseInt(data.intimacyGraph) || 1,
                relationship: data.relationshipType || "Unknown",
                interaction: data.interactionPlace || "Unknown"
            });
            totalCount++;
            sumIE += parseInt(data.ie); sumNS += parseInt(data.ns);
            sumFT += parseInt(data.ft); sumJP += parseInt(data.jp);
        });

        document.getElementById("average-mbti").textContent = `E/I: ${sumIE / totalCount}%  N/S: ${sumNS / totalCount}%  T/F: ${sumFT / totalCount}%  J/P: ${sumJP / totalCount}%`;
        updateCharts();
    }

    function updateCharts() {
        ["IE", "NS", "FT", "JP"].forEach(scale => {
            drawScaleChart(`chart${scale}`, `${scale} Scale`, dataPoints, scale);
        });
    }

    function drawScaleChart(canvasId, label, data, key) {
        const ctx = document.getElementById(canvasId).getContext("2d");
        if (charts[canvasId]) charts[canvasId].destroy();
        charts[canvasId] = new Chart(ctx, {
            type: "scatter",
            data: {
                datasets: [{
                    label: label, data: data.map(d => ({ x: d[key], y: Math.random() * 100, r: d.familiarity * 2 })),
                    backgroundColor: data.map(d => getColorForRelationship(d.relationship)),
                    pointStyle: data.map(d => getShapeForInteraction(d.interaction)),
                }]
            },
            options: { responsive: true, scales: { x: { min: 0, max: 100 }, y: { display: false } } }
        });
    }

    function getColorForRelationship(type) {
        return { "Friend": "#A3C4BC", "Family": "#E4C1F9", "Colleague": "#F4A261", "Romantic": "#E76F51", "Unknown": "#BDBDBD" }[type] || "black";
    }

    function getShapeForInteraction(place) {
        return { "Online": "circle", "Work": "triangle", "School": "rect", "Cafe": "star", "Sports": "cross" }[place] || "rectRot";
    }

    document.getElementById("relationship-filter").addEventListener("change", updateCharts);
    document.getElementById("interaction-filter").addEventListener("change", updateCharts);
    document.getElementById("familiarity-filter").addEventListener("change", updateCharts);

    fetchData();
</script>

</html> -->

<!-- <!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My MBTI Report</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <script src="switch_language.js" defer></script>
    <link rel="stylesheet" href="style3.css">
    <style>
        .chart-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            max-width: 90%;
            margin: 0 auto;
        }

        .chart-box {
            width: 45%;
            min-width: 300px;
            min-height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 14px;
        }

        .legend-item span {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }
    </style>
</head>

<body>
    <h1>My MBTI Report</h1>
    <p>This report shows the average MBTI perception others have of you.</p>

    <h2>Average MBTI Perception</h2>
    <p id="average-mbti">Loading...</p>

    <div id="legend-container" class="legend"></div>

    <div class="chart-container">
        <div class="chart-box"><canvas id="chartIE"></canvas></div>
        <div class="chart-box"><canvas id="chartNS"></canvas></div>
        <div class="chart-box"><canvas id="chartFT"></canvas></div>
        <div class="chart-box"><canvas id="chartJP"></canvas></div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
        import { getDatabase, ref, query, orderByChild, equalTo, get } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-database.js";

        let dataPoints = [];
        let charts = {};

        document.addEventListener("DOMContentLoaded", async () => {
            console.log("Loading MBTI report...");
            const firebaseConfig = {
                apiKey: "AIzaSyCvc9C5PuDqrI26jrmsg5b1PVOW6_k43W4",
                authDomain: "mbti-kale.firebaseapp.com",
                databaseURL: "https://mbti-kale-default-rtdb.asia-southeast1.firebasedatabase.app",
                projectId: "mbti-kale",
                storageBucket: "mbti-kale.firebasestorage.app",
                messagingSenderId: "756176954275",
                appId: "1:756176954275:web:7581e5e485e426b33ff016",
                measurementId: "G-B6F0F4JZ7E"
            };

            const app = initializeApp(firebaseConfig);
            const database = getDatabase(app);

            const urlParams = new URLSearchParams(window.location.search);
            const username = urlParams.get("username");

            if (!username) {
                alert("Invalid access. No username provided.");
                window.location.href = "index.html";
                return;
            }

            try {
                const dbRef = ref(database, "responses");
                const q = query(dbRef, orderByChild("username"), equalTo(username));
                const snapshot = await get(q);
                console.log(username);
                if (!snapshot.exists()) {
                    document.getElementById("average-mbti").textContent = "No data found.";
                    return;
                }

                console.log("Data found:", snapshot.val());

                let totalCount = 0;
                let sumIE = 0, sumNS = 0, sumFT = 0, sumJP = 0;
                let relationshipTypes = new Set();
                let interactionPlaces = new Set();
                let familiarityLevels = new Set();

                snapshot.forEach((childSnapshot) => {
                    const data = childSnapshot.val();
                    const familiarity = parseInt(data.intimacyGraph) || 1;

                    sumIE += parseInt(data.ie);
                    sumNS += parseInt(data.ns);
                    sumFT += parseInt(data.ft);
                    sumJP += parseInt(data.jp);

                    dataPoints.push({
                        IE: parseInt(data.ie),
                        NS: parseInt(data.ns),
                        FT: parseInt(data.ft),
                        JP: parseInt(data.jp),
                        familiarity: familiarity,
                        relationship: data.relationshipType || "Unknown",
                        interaction: data.interactionPlace || "Unknown",
                        y: Math.random() * 100
                    });

                    relationshipTypes.add(data.relationshipType || "Unknown");
                    interactionPlaces.add(data.interactionPlace || "Unknown");
                    familiarityLevels.add(familiarity);
                    totalCount++;
                });

                let avgIE = Math.round(sumIE / totalCount);
                let avgNS = Math.round(sumNS / totalCount);
                let avgFT = Math.round(sumFT / totalCount);
                let avgJP = Math.round(sumJP / totalCount);

                let finalIE = avgIE >= 50 ? "E" : "I";
                let finalNS = avgNS >= 50 ? "N" : "S";
                let finalFT = avgFT >= 50 ? "T" : "F";
                let finalJP = avgJP >= 50 ? "J" : "P";

                // 计算最终百分比
                let finalIEPercent = finalIE === "E" ? avgIE : 100 - avgIE;
                let finalNSPercent = finalNS === "N" ? avgNS : 100 - avgNS;
                let finalFTPercent = finalFT === "T" ? avgFT : 100 - avgFT;
                let finalJPPercent = finalJP === "J" ? avgJP : 100 - avgJP;

                console.log(username);

                // 在页面上显示最终的 MBTI 结果
                document.getElementById("average-mbti").textContent = `${finalIE} (${finalIEPercent}%)  ${finalNS} (${finalNSPercent}%)  ${finalFT} (${finalFTPercent}%)  ${finalJP} (${finalJPPercent}%)`;


                createLegend(relationshipTypes, interactionPlaces);
                drawScatterChart("chartIE", "I/E Scale", dataPoints, "IE");
                drawScatterChart("chartNS", "N/S Scale", dataPoints, "NS");
                drawScatterChart("chartFT", "F/T Scale", dataPoints, "FT");
                drawScatterChart("chartJP", "J/P Scale", dataPoints, "JP");

            } catch (error) {
                console.error("Error fetching data:", error);
                alert("Failed to load report.");
            }
        });

        function createLegend(types, types2) {
            const legendContainer = document.getElementById("legend-container");
            legendContainer.innerHTML = "";

            types.forEach(type => {
                const color = getColorForRelationship(type);
                const shaple = getShapeForInteraction(type);
                const legendItem = document.createElement("div");
                legendItem.className = "legend-item";
                legendItem.innerHTML = `<span style="background:${color}"></span>${type}`;
                legendContainer.appendChild(legendItem);
            });
        }

        function getColorForRelationship(relationship) {
            const colors = {
                "Friend": "#A3C1AD",
                "Family": "#EAC4D5",
                "Colleague": "#C3B1E1",
                "Romantic": "#F4A460",
                "Unknown": "#B3B3B3"
            };
            return colors[relationship] || "#777777";
        }

        function getShapeForInteraction(interaction) {
            const shapes = {
                "Online": "circle",
                "Work": "triangle",
                "School": "rect",
                "Home": "star",
                "Cafe": "diamond",
                "Sports": "cross"
            };
            return shapes[interaction] || "circle";
        }

        function drawScatterChart(canvasId, label, data, key) {
            const ctx = document.getElementById(canvasId).getContext("2d");

            const chartData = data.map(d => ({
                x: d[key],
                y: d.y,
                r: d.familiarity * 2
            }));

            if (charts[canvasId]) {
                charts[canvasId].destroy();
            }

            charts[canvasId] = new Chart(ctx, {
                type: "scatter",
                data: {
                    datasets: [{
                        label: label,
                        data: chartData,
                        backgroundColor: data.map(d => getColorForRelationship(d.relationship))
                    }]
                },
                options: {
                    responsive: true,
                    scales: { x: { min: 0, max: 100, title: { display: true, text: label } } }
                }
            });
        }
    </script>
</body>

</html> -->