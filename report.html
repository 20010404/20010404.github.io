<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My MBTI Report</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="switch_language.js" defer></script>
    <link rel="stylesheet" href="style3.css">
    <style>
        .chart-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            max-width: 90%;
            margin: 0 auto;
        }

        .chart-box {
            width: 45%;
            min-width: 300px;
            min-height: 250px;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .filters {
            text-align: center;
            margin-bottom: 20px;
        }
    </style>
</head>

<body>
    <h1>My MBTI Report</h1>
    <p>This report shows the average MBTI perception others have of you.</p>

    <h2>Average MBTI Perception</h2>
    <p id="average-mbti">Loading...</p>

    <div class="filters">
        <label for="relationship-filter">Filter by Relationship Type:</label>
        <select id="relationship-filter">
            <option value="all">All</option>
        </select>

        <label for="interaction-filter">Filter by Interaction Place:</label>
        <select id="interaction-filter">
            <option value="all">All</option>
        </select>

        <label for="familiarity-filter">Filter by Familiarity Level:</label>
        <select id="familiarity-filter">
            <option value="all">All</option>
        </select>
    </div>

    <div class="chart-container">
        <div class="chart-box"><canvas id="chartIE"></canvas></div>
        <div class="chart-box"><canvas id="chartNS"></canvas></div>
        <div class="chart-box"><canvas id="chartFT"></canvas></div>
        <div class="chart-box"><canvas id="chartJP"></canvas></div>
    </div>

</body>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
    import { getDatabase, ref, query, orderByChild, equalTo, get } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyCvc9C5PuDqrI26jrmsg5b1PVOW6_k43W4",
        authDomain: "mbti-kale.firebaseapp.com",
        databaseURL: "https://mbti-kale-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "mbti-kale",
        storageBucket: "mbti-kale.firebasestorage.app",
        messagingSenderId: "756176954275",
        appId: "1:756176954275:web:7581e5e485e426b33ff016",
        measurementId: "G-B6F0F4JZ7E"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    const urlParams = new URLSearchParams(window.location.search);
    const username = urlParams.get("username");

    if (!username) {
        alert("Invalid access.");
        window.location.href = "index.html";
    }

    let dataPoints = [];
    let charts = {};

    async function fetchData() {
        const dbRef = ref(database, "responses");
        const q = query(dbRef, orderByChild("username"), equalTo(username));
        const snapshot = await get(q);
        if (!snapshot.exists()) {
            document.getElementById("average-mbti").textContent = "No data found.";
            return;
        }

        let totalCount = 0;
        let sumI = 0, sumE = 0, sumN = 0, sumS = 0, sumF = 0, sumT = 0, sumJ = 0, sumP = 0;
        let relationshipTypes = new Set();
        dataPoints = [];
        let interactionPlaces = new Set();
        let familiarityLevels = new Set();
        snapshot.forEach((childSnapshot) => {
            const data = childSnapshot.val();

            function parseMBTI(value) {
                let percent = parseInt(value.replace(/[^0-9]/g, ""), 10); // 解析数值
                let type = value.replace(/[0-9%]/g, "").trim(); // 解析类型
                return { percent, type };
            }

            let ieData = parseMBTI(data.ie);
            let nsData = parseMBTI(data.ns);
            let ftData = parseMBTI(data.ft);
            let jpData = parseMBTI(data.jp);
            let ieValue = ieData.type === "I" ? 50 - (ieData.percent / 2) : 50 + (ieData.percent / 2);
            let nsValue = nsData.type === "N" ? 50 - (nsData.percent / 2) : 50 + (nsData.percent / 2);
            let ftValue = ftData.type === "F" ? 50 - (ftData.percent / 2) : 50 + (ftData.percent / 2);
            let jpValue = jpData.type === "J" ? 50 - (jpData.percent / 2) : 50 + (jpData.percent / 2);

            // Add to dataset
            dataPoints.push({
                IE: ieValue,
                NS: nsValue,
                FT: ftValue,
                JP: jpValue,
                familiarity: parseInt(data.intimacyGraph) || 1,
                relationship: data.relationshipType || "Other",
                interaction: data.interactionPlace || "Other"
            });
            // 累计 I/E
            if (ieData.type === "I") sumI += ieData.percent - 50;
            else sumE += ieData.percent - 50;

            // 累计 N/S
            if (nsData.type === "N") sumN += nsData.percent - 50;
            else sumS += nsData.percent - 50;

            // 累计 F/T
            if (ftData.type === "T") sumT += ftData.percent - 50;
            else sumF += ftData.percent - 50;

            // 累计 J/P
            if (jpData.type === "J") sumJ += jpData.percent - 50;
            else sumP += jpData.percent - 50;


            totalCount++;
        });

        // 计算最终百分比
        let avgI = sumI / totalCount;
        let avgE = sumE / totalCount;
        let avgN = sumN / totalCount;
        let avgS = sumS / totalCount;
        let avgF = sumF / totalCount;
        let avgT = sumT / totalCount;
        let avgJ = sumJ / totalCount;
        let avgP = sumP / totalCount;

        // 判断最终类型
        let finalIE = avgE >= avgI ? "E" : "I";
        let finalNS = avgN >= avgS ? "N" : "S";
        let finalFT = avgT >= avgF ? "T" : "F";
        let finalJP = avgJ >= avgP ? "J" : "P";

        // 计算最终胜出的百分比
        let finalIEPercent = finalIE === "E" ? avgE + 50 - avgI : avgI + 50 - avgE;
        let finalNSPercent = finalNS === "N" ? avgN + 50 - avgS : avgS + 50 - avgN;
        let finalFTPercent = finalFT === "T" ? avgT + 50 - avgF : avgF + 50 - avgT;
        let finalJPPercent = finalJP === "J" ? avgJ + 50 - avgP : avgP + 50 - avgJ;

        // 显示最终的 MBTI 结果，保留两位小数
        document.getElementById("average-mbti").textContent =
            `${finalIE} (${finalIEPercent.toFixed(2)}%)  
     ${finalNS} (${finalNSPercent.toFixed(2)}%)  
     ${finalFT} (${finalFTPercent.toFixed(2)}%)  
     ${finalJP} (${finalJPPercent.toFixed(2)}%)`;
        populateFilterDropdowns(relationshipTypes, interactionPlaces, familiarityLevels);
        updateCharts();
    }
    function populateFilterDropdowns() {
        const relationshipFilter = document.getElementById("relationship-filter");
        const interactionFilter = document.getElementById("interaction-filter");
        const familiarityFilter = document.getElementById("familiarity-filter");

        // Clear existing options except "All"
        relationshipFilter.innerHTML = '<option value="all">All</option>';
        interactionFilter.innerHTML = '<option value="all">All</option>';
        familiarityFilter.innerHTML = '<option value="all">All</option>';

        // Add predefined relationship types
        const relationshipTypes = ["Friend", "Family", "Colleague", "Romantic", "Other"];
        relationshipTypes.forEach(type => {
            const option = document.createElement("option");
            option.value = type;
            option.textContent = type;
            relationshipFilter.appendChild(option);
        });

        // Add predefined interaction places
        const interactionPlaces = ["Online", "Work", "School", "Home", "Cafe", "Sports", "Other"];
        interactionPlaces.forEach(place => {
            const option = document.createElement("option");
            option.value = place;
            option.textContent = place;
            interactionFilter.appendChild(option);
        });

        // Add predefined intimacy levels (1-7)
        for (let level = 1; level <= 7; level++) {
            const option = document.createElement("option");
            option.value = level;
            option.textContent = `Level ${level}`;
            familiarityFilter.appendChild(option);
        };
    }
    function updateCharts() {
        const relationshipFilter = document.getElementById("relationship-filter").value;
        const interactionFilter = document.getElementById("interaction-filter").value;
        const familiarityFilter = document.getElementById("familiarity-filter").value;

        // Filter data based on selected filters
        const filteredData = dataPoints.filter(d => {
            return (relationshipFilter === "all" || d.relationship === relationshipFilter) &&
                (interactionFilter === "all" || d.interaction === interactionFilter) &&
                (familiarityFilter === "all" || d.familiarity == familiarityFilter);
        });
        ["IE", "NS", "FT", "JP"].forEach(scale => {
            drawScaleChart(`chart${scale}`, scale, filteredData, scale);
        });
    }

    function drawScaleChart(canvasId, key, data, label) {
        const ctx = document.getElementById(canvasId).getContext("2d");
        if (charts[canvasId]) charts[canvasId].destroy();

        let axisLabels = {
            "IE": "I ←→ E",
            "NS": "N ←→ S",
            "FT": "F ←→ T",
            "JP": "J ←→ P"
        };

        // Get the appropriate labels for the x-axis based on the dimension
        let leftLabel = key.charAt(0);
        let rightLabel = key.charAt(1);

        charts[canvasId] = new Chart(ctx, {
            type: "bubble",
            data: {
                datasets: [{
                    label: label,
                    data: data.map(d => ({
                        x: d[key],
                        y: Math.random() * 2 + 5, // Reduced Y-axis range
                        r: d.familiarity * 1.1,
                        relationship: d.relationship, // Add relationship info for legend
                        interaction: d.interaction // Add interaction info for legend
                    })),
                    backgroundColor: data.map(d => getColorForRelationship(d.relationship)),
                    pointStyle: data.map(d => getShapeForInteraction(d.interaction)),
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                // Convert x value to show which trait is stronger
                                let value = context.parsed.x;
                                let trait = value <= 50 ? leftLabel : rightLabel;
                                let strength = value <= 50 ? 100 - value * 2 : (value - 50) * 2;
                                return `${trait}: ${Math.round(strength)}%`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        min: 0,
                        max: 100,
                        title: {
                            display: true,
                            text: axisLabels[key]
                        },
                        ticks: {
                            callback: function (value) {
                                if (value === 0) return leftLabel + " 100%";
                                if (value === 50) return "50/50";
                                if (value === 100) return rightLabel + " 100%";
                                return "";
                            }
                        }
                    },
                    y: { display: false } // Hide Y-axis
                }
            }
        });
    }


    function getAxisLabel(type) {
        return {
            "IE": "I ←→ E",
            "NS": "N ←→ S",
            "FT": "F ←→ T",
            "JP": "J ←→ P"
        }[type];
    }

    function getColorForRelationship(type) {
        return {
            "Friend": "#A3C4BC",
            "Family": "#E4C1F9",
            "Colleague": "#F4A261",
            "Romantic": "#E76F51",
            "Unknown": "#BDBDBD"
        }[type] || "black";
    }

    function getShapeForInteraction(place) {
        return {
            "Online": "circle",
            "Work": "triangle",
            "School": "rect",
            "Cafe": "star",
            "Sports": "cross"
        }[place] || "rectRot";
    }

    document.getElementById("relationship-filter").addEventListener("change", updateCharts);
    document.getElementById("interaction-filter").addEventListener("change", updateCharts);
    document.getElementById("familiarity-filter").addEventListener("change", updateCharts);

    fetchData();
</script>

</html>